<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwiftGG</title>
  
  <subtitle>走心的 Swift 翻译组</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://swift.gg/"/>
  <updated>2018-04-22T13:49:51.580Z</updated>
  <id>https://swift.gg/</id>
  
  <author>
    <name>SwiftGG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Twitter iOS 教程</title>
    <link href="https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2018/04/15/twitter-ios-tutorial-ios10/</id>
    <published>2018-04-15T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:51.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/03/14<br>译者：<a href="https://imiem.github.io" target="_blank" rel="noopener">imiem</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="noopener">pmst</a>；定稿：<a href="http://www.jianshu.com/u/2d46948e84e3" target="_blank" rel="noopener">mmoaay</a></p></blockquote><!--此处开始正文--><p>Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。</p><a id="more"></a><p>打开 Xcode，创建一个 Single View Application。<br><img src="/img/articles/twitter-ios-tutorial-ios10/single-view-xcode-templateformat=750w1523791017.6382737" alt=""></p><p>Product Name 命名为 <strong>IOS10TwitterTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier。Language 选择 Swift, 并确保 Devices 只选择了 iPhone。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791017.6963322" alt=""></p><p>转到 Storyboard，拖拽一个 Image View 到主页面上。选中 Image View 跳转到属性选项卡。在 View 部分使用 “Aspect Fit” 模式。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.7377508" alt=""></p><p>这种模式会使图片自适应 Image View。下一步，在页面的 Image View 下方添加两个 Button 按钮。title 分别设为 “Choose Image” 和 “Tweet”。</p><p>选中 Image View，点击 Storyboard 右下角 Auto Layout 的 Pin 按钮，填写下方的值，点击 Add 4 Constraints 按钮。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.786322" alt=""></p><p>按住 Cmd 键选中 “Choose Image” 和 “Tweet” 按钮。点击 Storyboard 右下角的 Align 按钮然后选择 “Horizontally in Container”。点击 “Add 2 Constraints” 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.8271823" alt=""></p><p>选中 “Choose Image” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中左边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.870292" alt=""></p><p>选中 “Tweet” 按钮，点击 Storyboard 右下方的 Auto Layout 的 Pin 按钮，选中右边的线，点击 Add 1 Constraint 按钮添加约束。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.91299" alt=""></p><p>Storyboard 看起来应如下图：</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.956209" alt=""></p><p>点击 Assistant Editor，确保 ViewController.swift 文件内容可见。接着选中 Image View ，按住 Ctrl 键鼠标左键拖拽一条线到  ViewController 类中，创建如下 Outlet 。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791017.964874" alt=""></p><p>同上，选中 Choose Image 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0067496" alt=""></p><p>选中 Tweet 按钮，按住 Ctrl 键拖拽到 ViewController 类中，创建如下 Action。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=300w1523791018.0520294" alt=""></p><p>要想使用 Social framework，首先要将其导入到工程中。添加如下代码到 ViewController.swift 文件中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Social</span><br></pre></td></tr></table></figure><p>ViewController 访问图库需要遵循 UINavigtionControllerDelegate 和 UiImagePickerControllerDelegate 协议。将声明 ViewController 的代码改为：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UINavigationControllerDelegate</span>, <span class="title">UIImagePickerControllerDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>在类中添加如下属性</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pickerController: <span class="type">UIImagePickerController</span> = <span class="type">UIImagePickerController</span>()</span><br></pre></td></tr></table></figure><p>下一步，实现 chooseImagePressed 方法</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">chooseImagePressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    pickerController.delegate = <span class="keyword">self</span></span><br><span class="line">    pickerController.sourceType = <span class="type">UIImagePickerControllerSourceType</span>.photoLibrary</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">self</span>.present(pickerController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 View Controller 设为代理，同时设置图库的 sourceType。</li><li>呈现图片选择视图控制器。</li></ol><p>下一步，实现 tweetButtonPressed 方法来创建分享页。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">tweetButtonPressed</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">SLComposeViewController</span>.isAvailable(forServiceType: <span class="type">SLServiceTypeTwitter</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> tweetSheet = <span class="type">SLComposeViewController</span>(forServiceType: <span class="type">SLServiceTypeTwitter</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tweetSheet = tweetSheet &#123;</span><br><span class="line">            tweetSheet.setInitialText(<span class="string">"Look at this nice picture!"</span>)</span><br><span class="line">            tweetSheet.add(imageView.image)</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">self</span>.present(tweetSheet, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下这个方法</p><ol><li>检查这个设备上是否有 twitter 账户。</li><li>创建 SLComposeViewController 对象，该对象用于显示推文界面和全部的功能。</li><li>在推文发布页面添加初始化文本和选中的图片。</li><li>显示推文发布页面。</li><li>如果没有 twitter 账户，在控制台打印一条信息。</li></ol><p>最后，实现 <code>imagePickerController:didFinishPickingMediaWithInfo</code> 方法。这里指定图库中的照片到 image view 上。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(<span class="number">_</span> picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])</span></span> &#123;</span><br><span class="line">    imageView.image = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.dismiss(animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想获得图库权限，必须要在 Info.plist 中添加一个键值（key）。打开 Info.plist 点击 + 添加如下键值。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=750w1523791018.0618207" alt=""></p><p>正常运行前，需要在 iOS 模拟器的设置中创建 Twitter 账号。</p><p>构建和运行工程。这个应用会请求访问图库的权限，点击允许。下一步，点击 “Choose Image”  按钮在图库中选择一张图片。下一步，点击 “Tweet” 按钮创建和发布推文。</p><p><img src="/img/articles/twitter-ios-tutorial-ios10/format=500w1523791018.070653" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 IOS10TwitterTutorial 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/twitter-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/03/14&lt;br&gt;译者：&lt;a href=&quot;https://imiem.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;imiem&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/596f2ba91ce9/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pmst&lt;/a&gt;；定稿：&lt;a href=&quot;http://www.jianshu.com/u/2d46948e84e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mmoaay&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Social Framework 使在 App 中使用社交分享成为可能。本教程中我们将从图库中选取一张图片，然后在 Twitter 中分享一个带图片的推文。本教程使用 Xcode 8.2.1 和 iOS 10.2。&lt;/p&gt;
    
    </summary>
    
      <category term="Arthur Knopper" scheme="https://swift.gg/categories/Arthur-Knopper/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Xcode9 中自定义文件头部注释和其他文本宏</title>
    <link href="https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/"/>
    <id>https://swift.gg/2017/12/10/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/</id>
    <published>2017-12-10T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ole Begemann，<a href="https://oleb.net/blog/2017/07/xcode-9-text-macros/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017/07/24<br>译者：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；校对：<a href="http://www.jianshu.com/users/9c51a213b02e/latest_articles" target="_blank" rel="noopener">Joy</a>；定稿：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a></p></blockquote><!--此处开始正文--><p>我一直<a href="https://twitter.com/olebegemann/status/845263246949011457" target="_blank" rel="noopener">不喜欢 Xcode 默认给新文件头部添加的注释</a>。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。</p><a id="more"></a><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/11.png1512891714.217959" alt=""></p><p>因此，在我个人的项目里，我创建新文件后，第一件要做的事情就是删除这些注释。</p><p>这个习惯一直持续到不久前，直到 Xcode9 允许使用一个 plist 文件来自定义文件头部注释和其他被称作文本宏的东西。这部分内容在 Xcode 的<a href="https://help.apple.com/xcode/mac/9.0/index.html" target="_blank" rel="noopener">帮助文档</a>中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev91a7a31fc" target="_blank" rel="noopener">自定义文本宏</a>这一页中有详尽的描述：</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-customize-text-macros.png1512892169.760428" alt=""></p><ol><li><strong>首先，创建一个叫做 <code>IDETemplateMacros.plist</code> 的 plist 文件</strong></li><li><p><strong>当你想自定义一个文本宏时，就向 plist 的字典中添加一个新的键。</strong>例如，当你想修改默认的文件头部注释时，就给 plist 文件中添加一个新条目，条目的键为 <code>FILEHEADER</code>。</p><p> <img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-plist-editor-IDETemplateMacros-plist.png1512892705.4828758" alt="在 Xcode 的 plist 编辑器中编辑`IDETemplateMacros.plist`文件"></p><blockquote><p>Xcode 的 plist 编辑器只会展示一行，不过你可以用 Option + Return 添加新行。</p></blockquote><p> 如果你想知道都有哪些文本宏可以使用，你可以查看<a href="#1">下方的文本宏参考</a>。你也可以在某个宏的值中使用其他宏，只要用下划线（译者注：三个下划线）包裹起来那个宏就可以了，比如：<code>___DATE___</code>。一些文本宏也可以用一种<code>:modifier</code>语法来进行进一步的自定义。通过查看<a href="#2">下方的文本宏格式参考</a>你可以得知更多细节。</p></li><li><p><strong>然后你可以把 plist 文件放到这么几个地方。放置的位置决定了自定义的文本宏会在什么范围内生效</strong>：</p><ul><li>使用该工程 (project) 的某个特定用户创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工程的所有人创建新文件时生效：<code>&lt;ProjectName&gt;.xcodeproj/xcshareddata/IDETemplateMacros.plist</code></li><li>使用该工作空间 (workspace) 的某个特定用户创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></li><li>使用该工作空间的所有人创建新文件时生效：<code>&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/IDETemplateMacros.plist</code> </li><li>使用 Xcode 创建的所有新文件都生效：<code>~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</code></li></ul></li></ol><p>当你创建一个新文件时，新文件的头部看起来像是这样：<br>​<br><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-new-file-after-customizing-text-macros.png1512892705.61613" alt="在自定义了`FILEHEADRE`文本宏后创建爱你的新文件"><br>​    </p><blockquote><p>注意，对于<code>FILEHEADER</code>宏，目前的 Xcode(Xcode9 beta3) 只会自动给第一行添加注释标记（一个不带空格的<code>//</code>），剩下的行并不会自动添加注释标记。你需要手动在带有宏的文本中添加注释标记。我不确定对 Xcode 来说这是一个 feature 还是一个 bug（对我来说现在看起来这是一个 bug）</p><p>因此，即便你在 plist 文件中把 <code>FILEHEADER</code> 设置成空字符串，也没法让文件头部的注释完全消失，新文件的开头会是一个空的注释行。我希望这个 bug 可以在未来的版本中解决掉。我已经给苹果官方提交了这个 bug（rdar://33451838）</p></blockquote><blockquote><p>译者注：<br>rdar 指的苹果内部的 bug 追踪系统，一般开发者可以在 <a href="https://bugreport.apple.com/" target="_blank" rel="noopener">https://bugreport.apple.com/</a> 上提交 bug，当然你只能看到自己提交的 bug，高冷的苹果不会展示出来总共有多少人提交了 bug，所以有人建立了 <a href="https://openradar.appspot.com/" target="_blank" rel="noopener">https://openradar.appspot.com/</a> 这个网站呼吁大家在提交 bug 后也在这里提交一次，方便开发者们知道都有哪些问题被提交了。更多详情可以参见这个<a href="https://forums.developer.apple.com/thread/8796" target="_blank" rel="noopener">论坛帖子</a></p></blockquote><hr><h2 id="1">文本宏索引</h2><p>这里是所有可以在 Xcode9 中使用的文本宏，我把他们从 <a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev7fe737ce0" target="_blank" rel="noopener">Xcode 的帮助页面</a>中一字不差的复制过来了。</p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macros-reference.png1512892705.665681" alt=""></p><blockquote><h5 id="DATE"><a href="#DATE" class="headerlink" title="DATE"></a>DATE</h5><p>当前的日期。</p><h5 id="DEFAULTTOOLCHAINSWIFTVERSION"><a href="#DEFAULTTOOLCHAINSWIFTVERSION" class="headerlink" title="DEFAULTTOOLCHAINSWIFTVERSION"></a>DEFAULTTOOLCHAINSWIFTVERSION</h5><p>当前工具链所使用的 Swift 的版本。</p><h5 id="FILEBASENAME"><a href="#FILEBASENAME" class="headerlink" title="FILEBASENAME"></a>FILEBASENAME</h5><p>不带扩展名的当前文件的名称。</p><h5 id="FILEBASENAMEASIDENTIFIER"><a href="#FILEBASENAMEASIDENTIFIER" class="headerlink" title="FILEBASENAMEASIDENTIFIER"></a>FILEBASENAMEASIDENTIFIER</h5><p>以 C 标识符编码的当前文件名称。（译者注：C 标识符只允许使用数字、字母和下划线，使用这个宏会把其他的字符自动替换成下划线）</p><h5 id="FILEHEADER"><a href="#FILEHEADER" class="headerlink" title="FILEHEADER"></a>FILEHEADER</h5><p>每个文本文件头部的文本。</p><h5 id="FILENAME"><a href="#FILENAME" class="headerlink" title="FILENAME"></a>FILENAME</h5><p>当前文件的完整名称。</p><h5 id="FULLUSERNAME"><a href="#FULLUSERNAME" class="headerlink" title="FULLUSERNAME"></a>FULLUSERNAME</h5><p>当前系统用户的全名。</p><h5 id="NSHUMANREADABLECOPYRIGHTPLIST"><a href="#NSHUMANREADABLECOPYRIGHTPLIST" class="headerlink" title="NSHUMANREADABLECOPYRIGHTPLIST"></a>NSHUMANREADABLECOPYRIGHTPLIST</h5><p>macOS 应用类型的 target 中，Info.plist 文件设置的版权信息条目的值（译者注：也就是这个宏最终会被替换成在 Info.plist 中 NSHumanReadableCopyright 这一项保存的字符串）。这个条目对应的一个合法的示例值为：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;</span><br><span class="line">&gt; &lt;string&gt;Copyright © 2017 Apple, Inc. All rights reserved.&lt;/string&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意值里头有一次换行<br><strong>ORGANIZATIONNAME</strong><br> Provisioning profile 文件中使用的团队所在的公司名称。<br><strong>PACKAGENAME</strong><br>当前 scheme 所设置的包名。<br><strong>PACKAGENAMEASIDENTIFIER</strong><br>当前 scheme 所设置的包名，以 C 标识符的形式编码。<br><strong>PRODUCTNAME</strong><br>当前 scheme 设置的应用名称。<br><strong>PROJECTNAME</strong><br>当前工程的名称。<br><strong>RUNNINGMACOSVERSION</strong><br>macOS 系统的版本。<br><strong>TARGETNAME</strong><br>当前 target 的名称。<br><strong>TIME</strong><br>当前的时间<br><strong>USERNAME</strong><br>当前 macOS 用户的登录名。<br><strong>UUID</strong><br>使用这个宏的时候，会返回一个唯一 ID。当这个宏第一次被使用时，Xcode 会创建一个 ID。你可以通过使用修饰符来创建多个唯一的 ID。每个修饰符都会得到一个针对这个修饰符唯一的 ID。</p><p>例如，<code>UUID:firstPurpose</code>这个宏和修饰符的组合在第一次使用的时候，它会创建并返回一个唯一的 ID。接下来其他使用 <code>UUID:firstPurpose</code>的地方都会返回这个 ID。使用 <code>UUID:secondPurpose</code> 后会产生并返回一个新的 ID，这个 ID 对于<code>UUID:secondPurpose</code>来说是唯一的，并且这个 ID 不同于前一个 ID。<br><strong>WORKSPACENAME</strong><br>当前 workspace 的名称。如果 workspace 中只有一个 project，那么这个宏的值便是当前打开的 project 的名称。<br><strong>YEAR</strong><br>四位数字格式的当前年数。</p></blockquote><hr><h2 id="2">文本宏格式索引</h2><p><em>以下内容都是从 Xcode 帮助页面中的<a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/devc8a500cb9" target="_blank" rel="noopener">文本宏格式参考</a>拷贝过来的</em></p><p><img src="/img/articles/Customizing-the-file-header-comment-and-other-text-macros-in-Xcode-9/xcode-help-text-macro-format-reference.png1512892705.816728" alt=""></p><blockquote><p>一个文本宏的值可以包含任何合法的 unicode 字符。同时一个文本宏的值也可以包含其他的文本宏。</p></blockquote><blockquote><h5 id="引入其他文本宏"><a href="#引入其他文本宏" class="headerlink" title="引入其他文本宏"></a>引入其他文本宏</h5><p>要想引入其他文本宏，在想要添加的文本宏之前和之后添加下划线(__):</p></blockquote><blockquote><p><code>___&lt;MacroName&gt;___</code></p><h5 id="编辑文本宏表达式"><a href="#编辑文本宏表达式" class="headerlink" title="编辑文本宏表达式"></a>编辑文本宏表达式</h5><p>通过添加一个或者多个修饰符，你可以修改文本宏的最终值。针对那些可以添加修饰符的文本宏，可以在宏的最后添加修饰符，宏和修饰符之间用分号(:)分隔。多个修饰符之间可以用逗号(,)分隔。</p></blockquote><blockquote><p><code>&lt;MACRO&gt;:&lt;modifier&gt;[,&lt;modifier&gt;]…</code></p><p>例如，下面的这段宏会删除掉<code>FILENAME</code>宏中的扩展名：</p></blockquote><blockquote><p><code>FILENAME:deletingPathExtension</code></p><p>为了使编辑后的宏符合 C 标识符的规范，可以在宏之后再添加一个 identifier 修饰符：</p><p><code>FILENAME:deletingPathExtension,identifier</code></p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="bundleIdentifier"><a href="#bundleIdentifier" class="headerlink" title="bundleIdentifier"></a>bundleIdentifier</h5><p>用一个连字符(-)替换所有不符合 bundle 标识的字符。</p><h5 id="deletingLastPathComponent"><a href="#deletingLastPathComponent" class="headerlink" title="deletingLastPathComponent"></a>deletingLastPathComponent</h5><p>从字符串中删除最后一个路径组件 (path component)。（译者注：根据<a href="https://en.wikipedia.org/wiki/Path_(computing" target="_blank" rel="noopener">维基百科</a>)的解释，一个路径是由多个路径组件组成的，路径组件之间使用斜线”/“、反斜线”\“或者句点”.“来分隔）</p><h5 id="deletingPathExtension"><a href="#deletingPathExtension" class="headerlink" title="deletingPathExtension"></a>deletingPathExtension</h5><p>从字符串中删除所有的扩展名。</p><h5 id="deletingTrailingDot"><a href="#deletingTrailingDot" class="headerlink" title="deletingTrailingDot"></a>deletingTrailingDot</h5><p>删除所有句子末尾的句点 (.)。</p><h5 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h5><p>用下划线(_)代替所有不符合 C 标识符编码的字符。</p><h5 id="lastPathComponent"><a href="#lastPathComponent" class="headerlink" title="lastPathComponent"></a>lastPathComponent</h5><p>仅返回字符最后一个路径组件。</p><h5 id="pathExtension"><a href="#pathExtension" class="headerlink" title="pathExtension"></a>pathExtension</h5><p>返回字符的扩展名。</p><h5 id="rfc1034Identifier"><a href="#rfc1034Identifier" class="headerlink" title="rfc1034Identifier"></a>rfc1034Identifier</h5><p>用连字符(-)替换所有不符合 rfc1034 标识符规范的字符。（译者注：rfc1034 是定义域名的规范，详情参见<a href="https://www.ietf.org/rfc/rfc1034.txt" target="_blank" rel="noopener">这里</a>）</p><h5 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h5><p>将一些特殊的 xml 字符用其转义字符替换。比如，小于号 (&lt;) 会被 &amp;lt 替换;</p></blockquote><hr><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Ole Begemann，&lt;a href=&quot;https://oleb.net/blog/2017/07/xcode-9-text-macros/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017/07/24&lt;br&gt;译者：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/9c51a213b02e/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Joy&lt;/a&gt;；定稿：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;我一直&lt;a href=&quot;https://twitter.com/olebegemann/status/845263246949011457&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不喜欢 Xcode 默认给新文件头部添加的注释&lt;/a&gt;。在我看来，从注释里得到的绝大多数信息要么和文件本身没有关系，要么通过版本控制，你能得到更详尽的信息。此外，当文件和项目更名的时候，这些注释会立刻显得过时。&lt;/p&gt;
    
    </summary>
    
      <category term="Ole Begemann" scheme="https://swift.gg/categories/Ole-Begemann/"/>
    
    
      <category term="Xcode" scheme="https://swift.gg/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>Core NFC 指南 - iOS 设备中的 NFC</title>
    <link href="https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/"/>
    <id>https://swift.gg/2017/09/25/core-nfc-tutorial-for-nfc-on-ios-devices/</id>
    <published>2017-09-25T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jameson Quave，<a href="http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-06<br>译者：<a href="http://www.desgard.com/" target="_blank" rel="noopener">冬瓜</a>；校对：<a href="http://forelax.space" target="_blank" rel="noopener">Forelax</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。</p><p>在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;w=5841512890761.307122" alt=""></p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/SD6Rm4cGyko" frameborder="0" allowfullscreen></iframe><p>由于 Core NFC 目前权限为只读状态，非接触式支付功能是不被开放的，但是仍旧有一些能够使用 Core NFC 读取能力的<del>使用</del>场景。下面我们来讲述一下。</p><p>使用 NFC 的第一步是在 Apple Developer Center 中通过 App ID 来启用它。创建一个新的 App ID，并启用 “NFC Tag Reading” 这个功能。</p><p><img src="/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/entitlement.pngzoom=2&amp;w=5841512890761.528886" alt=""></p><p>这之后，我建议专门为这个 App ID 创建一个 development/distribution provisioning profile 文件，这样当你尝试构建 App 的时候，NFC 读取功能将会自动加入。</p><p>接下来，你需要在 Xcode 项目中的 projectName.entitlements 中为的工程添加授权。你需要右键点击该文件并选择”Open As Source Code”，显示如图所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.nfc.readersession.formats<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>NDEF<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有 entitlements 文件，可以在项目中手动创建并把他加到工程的 build settings 中。在 “Build Settings” 下点击 “Coding Signing Entitlements” 选项并加入 entitlements 文件的相对路径。本例中是 “CoreNFC-Tutorial/CoreNFC-Tutorial.entitlements” ，因为我的工程文件在 “CoreNFC-Tutorial” 子目录下。</p><p>然后，需要为 Xcode 项目增加 usage string。打开 Info.plist 文件，增加 “Privacy - NFC Scan Usage Description” 这个键值。当用户使用 NFC 时，这个键值填写的内容会作为通知消息展示给用户，所以我们最好写一些有用的信息，比如可以填写 “NFC is needed to unlock doors.”。</p><p>接下来，在代码中引入 <code>CoreNFC</code> 模块。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CoreNFC</span><br></pre></td></tr></table></figure><p>备注：Core NFC 在 iOS 的模拟器上不可用， 即便是导入模块也会编译失败。因此 Core NFC 相关代码只能真机调试。</p><p>这里我创建了一个 <code>NFCHelper.swift</code> 文件，并将所有 NFC 相关的 API 调用封装成一个 NFCHelper 类。在 <code>init</code> 方法中我创建了一个会话 ，Core NFC 需要使用 <code>NFCNDEFReaderSession</code> 这个 class 来监听 NFC 设备，从而完成通信。（注意 <code>NFCReaderSession</code> 是一个抽象类，不能直接使用）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">      <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                           queue: <span class="literal">nil</span>,</span><br><span class="line">                           invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中我们创建了一个会话，并且为 <code>Dispatch Queue</code> 这个参数传递了一个 nil 值。这样可以使得 <code>NFCNDEFReaderSession</code> 自动创建一个串行 Dispatch Queue。</p><p>创建会话的时候，我们也要为 <code>NFCDEFReaderSession</code> 设置代理对象。这里我使用 <code>NFCHelper</code> class 来作为代理，所以我们需要遵守 <code>NFCNDEFReaderSessionDelegate</code> 协议。这个协议是基于 <code>NSObjectProtocol</code> 协议的，所以我们需要继承 <code>NSObject</code>（译者注：NSObject 协议在 Swift 中的名称为 NSObjectProtocol）。<code>NFCNDEFReaderSessionDelegate</code> 有两个必须实现的代理方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span></span><br></pre></td></tr></table></figure><p>当 NFC 的会话获取到验证错误，或是 NFC 的感应被触发时，这两个回调方法就会被调用。我们对回调信息的处理方式取决于我们 App 的使用场景，但是所有能够获取到的信息都可以通过 <code>didDetectNDEFs</code> 回调方法中的 <code>messages</code> 变量得到。在一开始，你可以通过遍历并打印 <code>messages</code> 中的元素来了解这些信息的内容。每个元素均是 <code>NFCDEFPayload</code> 对象，并且每一个对象都会包括 <code>identifier</code>、<code>payload</code>、<code>type</code> 和 <code>typeNameFormat</code> 这些属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Did detect NDEFs."</span>)</span><br><span class="line">  <span class="comment">// 遍历 messages 数组中所有元素</span></span><br><span class="line">  <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">      <span class="built_in">print</span>(record.identifier)</span><br><span class="line">      <span class="built_in">print</span>(record.payload)</span><br><span class="line">      <span class="built_in">print</span>(record.type)</span><br><span class="line">      <span class="built_in">print</span>(record.typeNameFormat)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们了解了这些属性的含义之后，就可以将其集成在前端 App 中，这里我针对我的应用创建了一个专门的回调方法，你应该也会做类似的事情，这里我增加了一个回调的属性，便于我的前端页面用这个属性来做进一步的展示：</p><p>当我从 NFC 获得一个有效信号或是一个错误的时候，会调用这个回调：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还实现了把创建会话的方法封装到了一个新的方法中，这样我就可以通过 <code>ViewController</code> 中的一个 button 点击触发来创建一个新的会话。关于 <code>NFCHelper.swift</code> 的最终代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NFCHelper.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CoreNFC</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NFCHelper</span>: <span class="title">NSObject</span>, <span class="title">NFCNDEFReaderSessionDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> onNFCResult: ((<span class="type">Bool</span>, <span class="type">String</span>) -&gt; ())?</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">restartSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> session =</span><br><span class="line">    <span class="type">NFCNDEFReaderSession</span>(delegate: <span class="keyword">self</span>,</span><br><span class="line">                       queue: <span class="literal">nil</span>,</span><br><span class="line">                       invalidateAfterFirstRead: <span class="literal">true</span>)</span><br><span class="line">    session.begin()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// MARK: NFCNDEFReaderSessionDelegate</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    onNFCResult(<span class="literal">false</span>, error.localizedDescription)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readerSession</span><span class="params">(<span class="number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> onNFCResult = onNFCResult <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> message <span class="keyword">in</span> messages &#123;</span><br><span class="line">      <span class="keyword">for</span> record <span class="keyword">in</span> message.records &#123;</span><br><span class="line">        <span class="keyword">if</span>(record.payload.<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> payloadString = <span class="type">String</span>.<span class="keyword">init</span>(data: record.payload, encoding: .utf8) &#123;</span><br><span class="line">              onNFCResult(<span class="literal">true</span>, payloadString)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我还搭建了一个简易的 UI 视图来展示这个类的用法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.swift</span></span><br><span class="line"><span class="comment">//  CoreNFC-Tutorial</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Jameson Quave on 6/6/17.</span></span><br><span class="line"><span class="comment">//  Copyright © 2017 Jameson Quave. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helper: <span class="type">NFCHelper</span>?</span><br><span class="line">  <span class="keyword">var</span> payloadLabel: <span class="type">UILabel</span>!</span><br><span class="line">  <span class="keyword">var</span> payloadText = <span class="string">""</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="comment">// 增加检测按钮</span></span><br><span class="line">    <span class="keyword">let</span> button = <span class="type">UIButton</span>(type: .system)</span><br><span class="line">    button.setTitle(<span class="string">"Read NFC"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    button.titleLabel?.font = <span class="type">UIFont</span>(name: <span class="string">"Helvetica"</span>, size: <span class="number">28.0</span>)</span><br><span class="line">    button.isEnabled = <span class="literal">true</span></span><br><span class="line">    button.addTarget(<span class="keyword">self</span>, action: #selector(didTapReadNFC), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">    button.frame = <span class="type">CGRect</span>(x: <span class="number">60</span>, y: <span class="number">200</span>, width: <span class="keyword">self</span>.view.bounds.width - <span class="number">120</span>, height: <span class="number">80</span>)</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(button)</span><br><span class="line">    <span class="comment">// 添加一个 Label 来显示状态</span></span><br><span class="line">    payloadLabel = <span class="type">UILabel</span>(frame: button.frame.offsetBy(dx: <span class="number">0</span>, dy: <span class="number">220</span>))</span><br><span class="line">    payloadLabel.text = <span class="string">"Press Read to see payload data."</span></span><br><span class="line">    payloadLabel.numberOfLines = <span class="number">100</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(payloadLabel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当 NFCHelper 已经处理过或者通信失败时调用</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">onNFCResult</span><span class="params">(success: Bool, message: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> success &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      payloadText = <span class="string">"<span class="subst">\(payloadText)</span>\n<span class="subst">\(message)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在主线程中更新 UI </span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">      <span class="keyword">self</span>.payloadLabel.text = <span class="keyword">self</span>.payloadText</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当用户点击 NFC 读取按钮时调用</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">didTapReadNFC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> helper == <span class="literal">nil</span> &#123;</span><br><span class="line">      helper = <span class="type">NFCHelper</span>()</span><br><span class="line">      helper?.onNFCResult = <span class="keyword">self</span>.onNFCResult(success:message:)</span><br><span class="line">    &#125;</span><br><span class="line">    payloadText = <span class="string">""</span></span><br><span class="line">    helper?.restartSession()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了以上的基本框架，你就可以结合你具体的需求来为你的 APP 添砖加瓦了。无论是识别客人身份、检测 Amiibo 状态（译者注：<a href="https://zh.wikipedia.org/wiki/Amiibo" target="_blank" rel="noopener">Amiibo</a> 是任天堂推出的基于 NFC 的玩偶），甚至是完成支付，Apple 推出的 Core NFC API 终于为这些新设备提供了完成各类 NFC 功能的可能性。如果你在开发任何集成了 NFC 功能的产品，欢迎发邮件到<a href="jquave@gmail.com">jquave@gmail.com</a>和我交流。</p><p><a href="https://github.com/jquave/TagReader" target="_blank" rel="noopener">完整源码</a></p><p><a href="https://www.youtube.com/watch?v=SD6Rm4cGyko&amp;feature=youtu.be" target="_blank" rel="noopener">视频教程</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jameson Quave，&lt;a href=&quot;http://jamesonquave.com/blog/core-nfc-tutorial-for-nfc-on-ios-devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-06&lt;br&gt;译者：&lt;a href=&quot;http://www.desgard.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冬瓜&lt;/a&gt;；校对：&lt;a href=&quot;http://forelax.space&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Forelax&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;在 iOS 11 发布后，开发者们首次可以在 iPhone7 或者更高的设备上调用 NFC 读取相关的接口。这些接口可以用于传递身份信息或者是用于实现类似门禁、地铁闸机这种功能的数据交换应用。&lt;/p&gt;
&lt;p&gt;在 iOS 11 中，这项技术被称作 Core NFC，下面我将在教程中使用 Swift 4 来讨论如何使用它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/articles/core-nfc-tutorial-for-nfc-on-ios-devices/nfc2.pngzoom=2&amp;amp;w=5841512890761.307122&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Jameson Quave" scheme="https://swift.gg/categories/Jameson-Quave/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>升级 CMake 使 Swift 的构建过程更加愉悦</title>
    <link href="https://swift.gg/2017/09/20/swift-option-sets/"/>
    <id>https://swift.gg/2017/09/20/swift-option-sets/</id>
    <published>2017-09-20T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016/06/30<br>译者：<a href="undefined">EyreFree</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p><img src="/img/articles/swift-option-sets/swift-og-1.png1512890761.873188" alt=""></p><p>开源 Swift 已经有一些更新来利用新版本的 <a href="https://cmake.org/" target="_blank" rel="noopener">CMake</a> <strong>在 Linux 上构建 Swift</strong>。需要指出的是，Ubuntu 14.04 (2.8.12.2) 自带的默认版 cmake 不再胜任这项工作。</p><p>让我们把 Ubuntu 14.04 的 CMake 升级到 3.4.3，<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160627/002299.html" target="_blank" rel="noopener">开发者表示</a>该版本可以满足需求。</p><p>当通过源代码安装软件时，通常会有一个构建区在 <code>/usr/local/src</code> 和一个存档区（所以可以跟踪我构建的版本）在 <code>/usr/local/archive</code>：</p><p>使用 root 账户或者用 sudo 方式执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /usr/local/archive</span></span><br><span class="line"><span class="comment"># wget https://cmake.org/files/v3.4/cmake-3.4.3.tar.gz</span></span><br><span class="line"><span class="comment"># cd ../src/</span></span><br><span class="line"><span class="comment"># tar -xzvf ../archive/cmake-3.4.3.tar.gz</span></span><br></pre></td></tr></table></figure><p>接下来，进行配置并且构建：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd cmake-3.4.3</span></span><br><span class="line"><span class="comment"># ./configure --prefix=/usr/local</span></span><br><span class="line">...</span><br><span class="line">CMake has bootstrapped.  Now run make.</span><br><span class="line"><span class="comment"># make</span></span><br></pre></td></tr></table></figure><p>最后，<code>make install</code> 会将 cmake 和它的关联设置安装到 <code>/usr/local</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make install</span></span><br><span class="line"><span class="comment"># which cmake</span></span><br><span class="line"><span class="comment"># cmake --version</span></span><br><span class="line">cmake version 3.4.3</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure><p>以上就是全部过程。构建愉快！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/upgrading-cmake-for-a-happier-swift-build/&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="Swift" scheme="https://swift.gg/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>从零构建 Dispatch Queue</title>
    <link href="https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/"/>
    <id>https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/</id>
    <published>2017-09-07T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html" target="_blank" rel="noopener">原文链接</a>，原文日期：2015-09-04<br>译者：<a href="http://hulizhen.me" target="_blank" rel="noopener">智多芯</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>分发队列（Dispatch Queue）是一个保存了多个基于全局线程池的任务（译者注：其实就是一系列的代码块）的队列。提交到队列的任务通常会被放到一个后台线程异步执行。为了使整个系统运作得更高效，所有的线程共享一个后台线程池。</p><p>这就是下面将要实现的 API 核心功能。为了简单起见，本文会略去很多 GCD 提供的额外功能。例如，全局线程池中的线程数量会随着任务总量和系统的 CPU 使用率进行动态调整。在已有一堆耗 CPU 的任务在运行的情形下，如果此时再提交一个任务，GCD 不会再为该任务创建新的线程。因为此时 CPU 已经满负荷运行了，再创建新的线程只会导致系统更低效。下面我会直接将线程数量硬编码在代码中。同样，其他的额外功能，如目标队列和并行队列屏障，也会一并略过。</p><p>本文会把重点放在实现分发队列的核心功能上：基于一个共享的全局线程池实现串行/并行及同步/异步派发任务。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>和往常一样，本文中的代码可在 GitHub 上获取：</p><p><a href="https://github.com/mikeash/MADispatchQueue" target="_blank" rel="noopener">https://github.com/mikeash/MADispatchQueue</a></p><p>可以边读本文边敲代码，也可以自己探索。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>GCD 提供的是一系列的 C 语言 API。虽然在最近发布的 OS 上 Apple 已经将 GCD 对象转成了 Objective-C 对象，但 API 还是保持着纯 C 语言接口（还新增了对 Block 支持）。这对底层 API 来说其实是好事，提供的接口也十分简洁。但本文将采用 Objective-C 语言来实现。</p><p>本文实现的 Objective-C 类叫做 <code>MADispatchQueue</code>，它只提供了四个方法：</p><ol><li>一个获取共享的全局队列的方法。GCD 有多个不同优先级的全局队列，但为了简单起见，我们只有一个全局队列。</li><li>一个构造器，可通过它创建并行或串行队列。</li><li>一个异步派发方法。</li><li>一个同步派发方法。</li></ol><p>接口的声明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MADispatchQueue : NSObject</span><br><span class="line"></span><br><span class="line">+ (MADispatchQueue *)globalQueue;</span><br><span class="line"></span><br><span class="line">- (id)initSerial: (BOOL)serial;</span><br><span class="line"></span><br><span class="line">- (void)dispatchAsync: (dispatch_block_t)block;</span><br><span class="line">- (void)dispatchSync: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>本文的目标就是实现这些方法的功能。</p><h3 id="线程池接口"><a href="#线程池接口" class="headerlink" title="线程池接口"></a>线程池接口</h3><p>用来支撑分发队列的线程池有着相对简洁的接口，该线程池负责执行被提交的作业。分发队列负责在合适的时机将已入队的作业提交到线程池。</p><p>线程池只有一个简单的任务：提交作业并执行。因此，它就只有一个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MAThreadPool : NSObject</span><br><span class="line"></span><br><span class="line">- (void)addBlock: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>因为这是整个线程池的核心，所以接下来先把它实现了。</p><h3 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h3><p>首先看下实例变量。线程池可能会被外部或内部的多个线程同时访问，因此必须保证其线程安全。虽然 GCD 尽可能地使用了快速原子操作以保证线程安全，但本文还是采用古老的锁方案。除了保证读写操作互斥外，该锁还要支持 <code>wait</code> 和 <code>signal</code> 操作，因此使用了 <code>NSCondition</code>，而不是原生的 <code>NSLock</code>。如果你不熟悉 <code>NSCondition</code> 也没关系，实际上它只是把锁和一个条件变量封装在一起而已：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSCondition *_lock;</span><br></pre></td></tr></table></figure><p>为了确定何时启动新的线程，需要知道当前线程池中有多少线程，有多少线程正在运行，线程池最多支持多少线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger _threadCount;</span><br><span class="line">NSUInteger _activeThreadCount;</span><br><span class="line">NSUInteger _threadCountLimit;</span><br></pre></td></tr></table></figure><p>最后是一个保存了多个代码块的数组。这里使用了 <code>NSMutableArray</code> 来实现队列，通过追加新的代码块到末尾来实现入队操作，通过删除开头的代码块来实现出队操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_blocks;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，只是初始化锁、代码块数组，最后将线程数的最大值设置成 123（随机选择的数目）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">    if((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSCondition alloc] init];</span><br><span class="line">        _blocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _threadCountLimit = 128;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程中主要是一个无限循环。当代码块数组为空时，线程进入休眠并等待。一旦数组不为空，该代码块立即出队并开始执行。代码块执行开始后，当前活跃线程数加一；代码块执行完成后，当前活跃线程数减一：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)workerThreadLoop: (id)ignore &#123;</span><br></pre></td></tr></table></figure><p>在进入循环之前先加锁，至于为什么这么做，请继续往下看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>接着进入无限循环：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (1) &#123;</span><br></pre></td></tr></table></figure><p>如果队列为空，则等待：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while ([_blocks count] == 0) &#123;</span><br><span class="line">   [_lock wait];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，上面代码是在一个循环中，而不仅仅只是一个 <code>if</code> 语句。这么做是因为<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">假性唤醒</a>。简单地说，即使没有发送<code>signal</code>信号，<code>wait</code> 也可能提前返回。为了让代码产生预期的行为，<code>wait</code> 返回时每次都要检查代码块的数量。</p><p>一旦有了可用代码块，立即出队：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_block_t block = [_blocks firstObject];</span><br><span class="line">[_blocks removeObjectAtIndex: 0];</span><br></pre></td></tr></table></figure><p>将当前活跃线程数加一，表明当前线程正忙：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_activeThreadCount++;</span><br></pre></td></tr></table></figure><p>现在是时候开始执行代码块了。但在此之前需要先解锁，否则就无法并发执行代码，并且所有试图对该锁加锁的线程都会导致死锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure><p>安全地解锁并立即执行代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>当该代码块执行完后，将当前活跃线程数减一。在这样做之前需要先加锁以避免竞争条件。到这里循环也就结束了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        [_lock lock];</span><br><span class="line">        _activeThreadCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在应该明白为什么进入上面这个循环之前先加锁了。循环中的最后一步是将当前活跃线程数减一，进入循环的第一步是检查队列中的代码块数量，而这两个操作都需要先加锁。通过在循环外加锁，后续的迭代只需要加一次锁即可。而不需要加锁、解锁，又马上加锁。</p><p>现在来看看 <code>addBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addBlock: (dispatch_block_t)block &#123;</span><br></pre></td></tr></table></figure><p>这个方法中的所有操作都需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure><p>第一件事就是将传入的代码块添加到队列中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_blocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果目前有空闲的工作线程可以执行该代码块，那么就没什么需要做的了。如果没有空闲线程去处理这个还未被执行的代码块，并且工作线程总数还没超出限制，那就新建一个线程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUInteger idleThreads = _threadCount - _activeThreadCount;</span><br><span class="line">   if([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) &#123;</span><br><span class="line">   [NSThread detachNewThreadSelector: @selector(workerThreadLoop:)</span><br><span class="line">                                toTarget: self</span><br><span class="line">                              withObject: nil];</span><br><span class="line">       _threadCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>现在有了空闲的工作线程可以执行代码块了。但 <code>workerThreadLoop</code> 中的循环可能由于 <code>wait</code> 操作而处于休眠状态，因此执行一下 <code>signal</code> 操作唤醒它：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock signal];</span><br></pre></td></tr></table></figure><p>最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现的线程池能够创建预定数目的工作线程以便执行新入队的代码块。接下来就利用这个线程池去实现分发队列 <code>Dispatch Queue</code>。</p><h3 id="分发队列的实现"><a href="#分发队列的实现" class="headerlink" title="分发队列的实现"></a>分发队列的实现</h3><p>和线程池相同的是，分发队列同样需要一个锁。而不同的是，它并不需要 <code>wait</code> 和 <code>signal</code>操作，只需要最基本的互斥锁 <code>NSLock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLock *_lock;</span><br></pre></td></tr></table></figure><p>类似线程池，分发队列使用 <code>NSMutableArray</code> 维护了一个队列用于保存还未被执行的代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *_pendingBlocks;</span><br></pre></td></tr></table></figure><p><code>Dispatch Queue</code> 需要知道自己是串行还是并行队列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serial;</span><br></pre></td></tr></table></figure><p>如果是串行队列，它还需要跟踪线程池中是否有代码块正在执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL _serialRunning;</span><br></pre></td></tr></table></figure><p>并行队列则不管是否有代码块正在运行都不影响，因此不需要跟踪该状态。</p><p>和共享的线程池一样，将全局队列保存在一个全局变量中，二者都在 <code>+initialize</code> 方法中创建：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static MADispatchQueue *gGlobalQueue;</span><br><span class="line">static MAThreadPool *gThreadPool;</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    if(self == [MADispatchQueue class]) &#123;</span><br><span class="line">        gGlobalQueue = [[MADispatchQueue alloc] initSerial: NO];</span><br><span class="line">        gThreadPool = [[MAThreadPool alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+initialize</code> 方法已经确保了全局队列会被创建，因此 <code>+globalQueue</code> 方法可直接返回 <code>gGlobalQueue</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (MADispatchQueue *)globalQueue &#123;</span><br><span class="line">    return gGlobalQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本来是可以直接用 <code>dispatch_once</code> 方法的，但这么做会有种使用了 GCD API 来作弊的感觉，说好的要从零构建的，虽然这并不是我们要实现的 API。</p><p>初始化方法包括分配锁、创建代码块队列（译者注：还未被执行的代码块），还要设置 <code>_serial</code> 变量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)initSerial: (BOOL)serial &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _lock = [[NSLock alloc] init];</span><br><span class="line">        _pendingBlocks = [[NSMutableArray alloc] init];</span><br><span class="line">        _serial = serial;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲其余的公开 API 之前，还有一个底层方法需要实现。这个方法会在线程池中将 <code>_pendingBlocks</code> 队列中的一个代码块取出并执行，接着还很有可能（串行队列的情况下）会调用自身在线程池中执行另一个代码块：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchOneBlock &#123;</span><br></pre></td></tr></table></figure><p>该方法唯一的职责就是在线程池中执行代码块，所以把自身的功能代码块添加到线程池中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[gThreadPool addBlock: ^&#123;</span><br></pre></td></tr></table></figure><p>接着从队列中取出队列头部的代码块。当然了，这个操作也需要加锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_lock lock];</span><br><span class="line">      dispatch_block_t block = [_pendingBlocks firstObject];</span><br><span class="line">      [_pendingBlocks removeObjectAtIndex: 0];</span><br><span class="line">      [_lock unlock];</span><br></pre></td></tr></table></figure><p>在解锁后，上面取出的代码块就可以安全地在后台线程执行（译者注：在前文线程池的实现中可以看出，每个添加到线程池中的代码块都会在独立的后台线程中执行）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure><p>如果队列是并行的，那么到这里就结束了。如果是串行的话，还需要下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial) &#123;</span><br></pre></td></tr></table></figure><p>在串行队列上，新增的代码块需要等到前一个代码块执行完后才能执行。每当一个代码块执行完后，<code>dispatchOneBlock</code> 会检查当前队列是否还有代码块未执行。如果有的话，它会调用自身以便最后可以执行到该代码块。如果没有，将队列的运行状态设置回 <code>NO</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            [_lock lock];</span><br><span class="line">            if([_pendingBlocks count] &gt; 0) &#123;</span><br><span class="line">                [self dispatchOneBlock];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _serialRunning = NO;</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面这个方法之后，实现 <code>dispatchAsync</code> 就相对简单了。将代码块添加到队列中，然后根据情况（是否为串行队列）设置队列的运行状态并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchAsync: (dispatch_block_t)block &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    [_pendingBlocks addObject: block];</span><br></pre></td></tr></table></figure><p>如果是串行队列且当前空闲，就将队列运行状态设置为 <code>YES</code> 并调用 <code>dispatchOneBlock</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(_serial &amp;&amp; !_serialRunning) &#123;</span><br><span class="line">    _serialRunning = YES;</span><br><span class="line">    [self dispatchOneBlock];</span><br></pre></td></tr></table></figure><p>如果是并行队列，就无条件直接执行。这样保证了即使其他代码块正在执行，新增的代码块也能尽快执行，毕竟并行队列是允许多个代码块同时运行的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; else if (!_serial) &#123;</span><br><span class="line">       [self dispatchOneBlock];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果串行队列已经在执行代码块了，就没什么需要做的了，已经在执行的 <code>dispatchOneBlock</code>最后会执行到新增的代码块的。最后解锁：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来轮到 <code>dispatchSync</code> 了。与 GCD 的实现不同，本文直接使用 <code>dispatchAsync</code> 派发代码块，并等到代码执行完后再返回（译者注：这就是同步的效果）。</p><p>为了实现这个目的，这里使用到了一个本地条件变量 <code>NSCondition</code>，还有一个 <code>done</code> 变量用于表示代码块是否执行完毕：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)dispatchSync: (dispatch_block_t)block &#123;</span><br><span class="line">   NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">   __block BOOL done = NO;</span><br></pre></td></tr></table></figure><p>接着异步派发代码块。这里执行了通过函数参数传进来的代码块，然后设置 <code>done</code> 为 <code>YES</code>并唤醒 <code>condition</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self dispatchAsync: ^&#123;</span><br><span class="line">    block();</span><br><span class="line">    [condition lock];</span><br><span class="line">    done = YES;</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在条件变量 <code>condition</code> 上等待 <code>done</code> 被设置成 <code>YES</code>，然后返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    [condition lock];</span><br><span class="line">    while (!done) &#123;</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就成功地运行了代码块，这也是 <code>MADispatchQueue</code> 所需要的最后一个 API 。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可以通过一个保存代码块的队列和动态创建和销毁线程的方法来实现一个全局的线程池。通过使用一个共享的全局线程池，可以构建基本的 <code>Dispatch Queue</code> API，支持串行/并行及同步/异步派发任务。本文的实现少了许多 GCD 中很赞的功能，而且也确实比 GCD 低效得多。但即便如此，本文还是可以让你窥视到 GCD 内部的运作原理，让你明白这其实也不是什么神奇的事。（除了 <code>dispatch_once</code>，着简直就是个魔法。）</p><p>这就是今天所有的内容了，记得不要错过下一次更多有趣的内容哦。另外，周五的 Q&amp;A 是由读者驱动的，所以如果你有什么想在这里讨论的，给我<a href="mailto:mike@mikeash.com" target="_blank" rel="noopener">发个邮件</a>吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Mike Ash，&lt;a href=&quot;https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2015-09-04&lt;br&gt;译者：&lt;a href=&quot;http://hulizhen.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;智多芯&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Grand Central Dispatch 是 Apple 公司最近几年推出的重量级 API 之一。在本次“从零构建”系列文章中，我们将探索一个由 Rob Rix 建议的主题：从零构建一个具备基本功能的 Dispatch Queue。&lt;/p&gt;
    
    </summary>
    
      <category term="Mike Ash" scheme="https://swift.gg/categories/Mike-Ash/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何用 UIKit Dynamics 进行碰撞检测</title>
    <link href="https://swift.gg/2017/09/06/collision-detection-uikit-dynamics-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/09/06/collision-detection-uikit-dynamics-ios-tutorial-ios10/</id>
    <published>2017-09-06T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/collision-detection-uikit-dynamics-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-20<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>用 UIKit Dynamics 可以让指定对象具备碰撞行为。动态的项目能相互碰撞或者和任何指定的边界碰撞。在本节教程中，将学习创建自行一的边界，随机地让一些方块下落到边界上。本节教程使用的是 Xcode 8.3 和 iOS 10.3。</p><a id="more"></a><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application 工程。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1504677793.38" alt=""></p><p>Product Name 使用 <strong>IOS10CollisionDectectionTutorial</strong>（译者注：这里的 Dectection 估计是错别字，应该是 Detection），填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/line-view-uiviewformat=1500w1504677799.47" alt=""></p><p>用自定义的 UIView 画一些线，在 drawRect 方法中写点代码。选择 File -&gt; New File -&gt; iOS -&gt; Source -&gt; Cocoa Touch Class。Class 命名为 LineView，其父类为 UIView。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/line-view-uiviewformat=1500w1504677799.47" alt=""></p><p>打开 <strong>LineView.swift</strong> 文件，想要画线需要先创建一个帮手：<strong>drawLineFromPoint(fromX:toPoint:pointY:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawLineFromPoint</span><span class="params">(fromX: CGFloat, toPoint toX: CGFloat, pointY y: CGFloat)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentContext = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> currentContext = currentContext &#123;</span><br><span class="line">        currentContext.setLineWidth(<span class="number">5.0</span>)</span><br><span class="line">        currentContext.move(to: <span class="type">CGPoint</span>(x: fromX, y: y))</span><br><span class="line">        currentContext.addLine(to: <span class="type">CGPoint</span>(x: toX, y: y))</span><br><span class="line">        currentContext.strokePath();</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>线的宽度为 5 points。接下来，改写 <strong>drawRect</strong> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    drawLineFromPoint(fromX: <span class="number">0</span>, toPoint: bounds.size.width/<span class="number">3</span>, pointY: bounds.size.height - <span class="number">100.0</span>)</span><br><span class="line">    drawLineFromPoint(fromX: bounds.size.width/<span class="number">3</span>, toPoint:bounds.size.width*<span class="number">0.67</span>, pointY:bounds.size.height - <span class="number">150.0</span>)</span><br><span class="line">    drawLineFromPoint(fromX: bounds.size.width*<span class="number">0.67</span>, toPoint:bounds.size.width, pointY:bounds.size.height - <span class="number">100.0</span>)&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/custom-class-identity-inspectorformat=500w1504677802.86" alt=""></p><p><strong>运行</strong>工程，线已经出现在屏幕上了。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/format=750w1504677808.44" alt=""></p><p>接下来，拖拽一个 Button 控件到 Storyboard 上，标题改为 “Next”。选中该 Button，点击 Auto Layout 的 Align 按钮，勾选 “Horizontally in Container”，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1504677809.87" alt=""></p><p>继续选中该 Button，点击 Auto Layout 的 Pin 按钮，选中上边距的约束线，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/button-pin-to-topformat=750w1504677818.01" alt=""></p><p>主界面看起来应如下图所示：</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/collision-detection-storyboardformat=750w1504677819.34" alt=""></p><p>点击 Assistant Editor，确保 ViewController.swift 文件可见，按住 Control 键将该 Button 拖拽到 ViewController 类里，创建下列 Action 链接：</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/release%3Dsquare-actionformat=750w1504677820.03" alt=""></p><p>在 <strong>ViewController.swift</strong> 文件中，需要声明一些变量，来跟踪记录 view，如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squareViews:[<span class="type">UIView</span>] = []</span><br><span class="line"><span class="keyword">var</span> animator:<span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="keyword">var</span> colors:[<span class="type">UIColor</span>] = []</span><br><span class="line"><span class="keyword">var</span> centerPoint:[<span class="type">CGPoint</span>] = []</span><br><span class="line"><span class="keyword">var</span> sizeOfSquare:<span class="type">CGSize</span>!</span><br></pre></td></tr></table></figure><p>squareViews 将包含所需的 view，view 需要颜色数组、centerPin 数组和 sizeOfSquare（方块的大小）这些属性。animator 属性要用于动画动作。接下来继续添加下列属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> rightBoundaryHeight:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> leftBoundaryWidth:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleBoundaryWidth:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> leftSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> middleSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> rightSquareCenterPointX:<span class="type">CGFloat</span>!</span><br><span class="line"><span class="keyword">var</span> squareCenterPointY:<span class="type">CGFloat</span>!</span><br></pre></td></tr></table></figure><p>需要上述属性来设置自定义的边界，给所有的方块添加一个起始点。首先，创建 setBoundaryValues 方法来设置上述属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setBoundaryValues</span><span class="params">()</span></span> &#123;</span><br><span class="line">    leftBoundaryHeight = view.bounds.size.height - <span class="number">100.0</span></span><br><span class="line">    middleBoundaryHeight = view.bounds.size.height - <span class="number">150.0</span></span><br><span class="line">    rightBoundaryHeight = view.bounds.size.height - <span class="number">100.0</span></span><br><span class="line">    leftBoundaryWidth = view.bounds.size.width/<span class="number">3</span></span><br><span class="line">    middleBoundaryWidth = view.bounds.size.width * <span class="number">0.67</span></span><br><span class="line">    leftSquareCenterPointX = view.bounds.size.width/<span class="number">6</span></span><br><span class="line">    middleSquareCenterPointX = view.bounds.size.width/<span class="number">2</span></span><br><span class="line">    rightSquareCenterPointX = view.bounds.size.width * <span class="number">0.84</span></span><br><span class="line">    squareCenterPointY = view.bounds.size.height - <span class="number">400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>viewDidLoad</strong> 里，调用上述方法。然后设置剩下的属性。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    setBoundaryValues()</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建颜色数组</span></span><br><span class="line">    colors = [<span class="type">UIColor</span>.red, <span class="type">UIColor</span>.blue, <span class="type">UIColor</span>.green, <span class="type">UIColor</span>.purple, <span class="type">UIColor</span>.gray]</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建方块的中心点（centerpoint）</span></span><br><span class="line">    <span class="keyword">let</span> leftCenterPoint = <span class="type">CGPoint</span>(x: leftSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    <span class="keyword">let</span> middleCenterPoint = <span class="type">CGPoint</span>(x: middleSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    <span class="keyword">let</span> rightCenterPoint = <span class="type">CGPoint</span>(x:rightSquareCenterPointX, y: squareCenterPointY)</span><br><span class="line">    centerPoint = [leftCenterPoint,middleCenterPoint,rightCenterPoint]</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 设置方块的大小</span></span><br><span class="line">    sizeOfSquare = <span class="type">CGSize</span>(width: <span class="number">50.0</span>, height: <span class="number">50.0</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在每个 view 的尺寸是 50，有 5 种不同的颜色。接下来的事情都会在 <strong>releaseNextSquare(sender:)</strong> 方法中发生。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">releaseSquare</span><span class="params">(<span class="number">_</span> sender: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: sizeOfSquare.width, height: sizeOfSquare.height))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> randomColorIndex = <span class="type">Int</span>(arc4random()%<span class="number">5</span>)</span><br><span class="line">    newView.backgroundColor = colors[randomColorIndex]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> randomCenterPoint = <span class="type">Int</span>(arc4random()%<span class="number">3</span>)</span><br><span class="line">    newView.center = centerPoint[randomCenterPoint]</span><br><span class="line">        </span><br><span class="line">    squareViews.append(newView)</span><br><span class="line">    view.addSubview(newView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 view，centerPoint 的值是随机数，也赋值了颜色，该 view 被添加到了主界面上，也被添加到了数组中。在 <strong>releaseSquare(sender:)</strong> Action 方法的最后，添加剩下的代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建重力</span></span><br><span class="line"><span class="keyword">let</span> gravity = <span class="type">UIGravityBehavior</span>(items: squareViews)</span><br><span class="line">animator.addBehavior(gravity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建碰撞检测</span></span><br><span class="line"><span class="keyword">let</span> collision = <span class="type">UICollisionBehavior</span>(items: squareViews)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 设置碰撞的边界</span></span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"leftBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: <span class="number">0.0</span>,y: leftBoundaryHeight), to: <span class="type">CGPoint</span>(x: leftBoundaryWidth, y: leftBoundaryHeight))</span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"middleBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: view.bounds.size.width/<span class="number">3</span>,y: middleBoundaryHeight), to: <span class="type">CGPoint</span>(x: middleBoundaryWidth, y: middleBoundaryHeight))</span><br><span class="line">collision.addBoundary(withIdentifier: <span class="string">"rightBoundary"</span> <span class="keyword">as</span> <span class="type">NSCopying</span>, from: <span class="type">CGPoint</span>(x: middleBoundaryWidth,y: rightBoundaryHeight), to: <span class="type">CGPoint</span>(x: view.bounds.size.width, y: rightBoundaryHeight))</span><br><span class="line">        </span><br><span class="line">collision.collisionMode = .everything</span><br><span class="line">animator.addBehavior(collision)</span><br></pre></td></tr></table></figure><p>首先，给方块下落的动作增加了重力，接下来，在自定义边界的基础上添加了碰撞行为。默认的碰撞模式是 UICollisionBehaviour 里的 UICollisionBehaviourMode.everything，也就是说，所有的元素都可以互相碰撞。<strong>运行</strong>工程，不停地按 Next 按钮，方块下落。</p><p><img src="/img/articles/collision-detection-uikit-dynamics-ios-tutorial-ios10/collision-detection-simulatorformat=750w1504677820.83" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10CollisionDectectionTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/collision-detection-uikit-dynamics-ios-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-20&lt;br&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;用 UIKit Dynamics 可以让指定对象具备碰撞行为。动态的项目能相互碰撞或者和任何指定的边界碰撞。在本节教程中，将学习创建自行一的边界，随机地让一些方块下落到边界上。本节教程使用的是 Xcode 8.3 和 iOS 10.3。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的并发编程(第一部分：现状）</title>
    <link href="https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/"/>
    <id>https://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</id>
    <published>2017-09-04T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Umberto Raimondi，<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-05-07<br>译者：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。<br>如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。<br>在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。</p><p>同时也会讨论到基础的并发原理和一些通用的并发模式。</p><a id="more"></a><p>原文链接：<a href="https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">All about Concurrency in Swift - Part 1: The Present</a></p><p><img src="/img/articles/all-about-concurrency-in-swift-1-the-present/concurr.png1504576909.77" alt=""></p><p>虽然在那些可以运行 Swift 的平台上，都可以使用 pthread 库来处理并发（译者注：pthread 库是跨平台的），但是在这里，不会讨论 pthread 库相关的函数和原语，对于这些底层一些库函数来说，有更高阶的替代者。NSTimer 类也不会在这里讨论，请查阅<a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="noopener">这篇文章</a>，告诉你如何在 Swift 3中使用它。</p><p>正如已经被多次提到的一样，在 Swift 4.0 发布后的某个版本（应该不需要等到 Swift 5），Swift 语言将会定义一个牛逼的内存模型，包含支持原生并发特性，用于处理并发，和并行一样，不需要引入外部库，使用 Swift 的方式来处理并发。</p><p>在下一篇系列文章中，将会讨论其他语言中使用的一些替代方式和范式实现并发，并且探讨如何在 Swift 中实现它们，然后分析一些已经存在的开源实现，<br>并且使用了当前发布版本的 Swift  编写 Actors 模式，CSP 通道（Go 语言），STM（Software Transactional Memory）等并发实现。<br>在当前的 Swift 正式版本中允许使用行动者范式，Go 语言的 CSP 频道，软件事务内存。</p><p>在第二篇文章中，将会彻底预测下，主要预测方式，是把这些涉及的对象的情况做个介绍，这样可以让你可以身临其境，明白将会在未来的 Swift 版本如何定义处理并发。</p><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#multithreading_and_concurrency_primer">多线程和并发启蒙</a></li><li><a href="#language_guarantees">语言支持</a></li><li><a href="#threads">线程类</a></li><li><p><a href="#synchronization_primitives">同步原语</a></p><ul><li><a href="#nslock">NSLock</a></li><li><a href="#nsrecursivelock">NSRecursiveLock</a></li><li><a href="#nsconditionlock">NSConditionLock</a></li><li><a href="#nscondition">NSCondition</a></li><li><a href="#nsdistributedlock">NSDistributedLock</a></li><li><a href="#osatomic_where_art_thou">OSAtomic 还能用吗？</a></li><li><a href="#on_synchronized_blocks">同步代码块</a></li></ul></li><li><p><a href="#grand_central_dispatch">GCD：Grand Central Dispatch</a></p><ul><li><a href="#dispatch_queues">调度队列</a></li><li><a href="#using_quenes">使用队列</a></li><li><a href="#barriers">屏障</a></li><li><a href="#singletons_and_dispatch_once">单例和 Dispatch_once</a></li><li><a href="#dispatch_groups">调度组</a></li><li><a href="#dispatch_work_items">调度工作项</a></li><li><a href="#dispatch_semaphores">调度信号量</a></li><li><a href="#dispatch_assertions">调度断言</a></li><li><a href="#dispatch_sources">调度资源</a></li></ul></li><li><p><a href="#operations_and_operationqueues">操作和操作队列</a></p></li><li><a href="#closing_thoughts">后记</a></li></ul><p><a name="multithreading_and_concurrency_primer"></a></p><h2 id="多线程和并发启蒙"><a href="#多线程和并发启蒙" class="headerlink" title="多线程和并发启蒙"></a>多线程和并发启蒙</h2><p>现如今，无论大家编写何种类型的应用，迟早大家会发现一个事实，应用都会运行在一个多线程的执行环境下面。</p><p>使用多处理器或者拥有多个硬件执行核心处理器的计算平台已经出现了几个时代了，并且像 <em>线程</em> 和 <em>进程</em> 等概念出现的甚至更早。</p><p>操作系统通过使用各种程序来利用硬件的能力，而应用或每一个现代的框架都在实现一些大家熟知的设计模式，用到了多线程来增强自身的灵活性和性能。</p><p>在我们开始深入讨论如何使用 Swift 处理多线程之前，先来解释一些需要了解的基本概念，这样才能考虑应该使用调度队列（<code>Dispatch Queues</code>）或者操作队列（<code>Operation Queues</code>）。<br>首先，你可能会问，苹果平台和框架已经使用了线程，为啥还需要在应用中单独介绍它们呢？<br>有少量通用的场景下，让使用多线程变得容易理解：</p><p><strong>任务组隔离</strong>：线程可以从执行流程角度模块化应用，不同线程用可预测的方式执行同类的一组任务，隔离应用中其他执行流程，这样对应用当前的状态更加可控。</p><p><strong>数据独立并行计算</strong>：多个软件线程，无论是基于硬件线程还是不基于软件线程(见下一个要点)，都通过并行处理同一个任务的多个拷贝，这个任务作用于原始输入数据结构的其中某个子集。</p><p><strong>更加清晰的方式等待竞争或I/O</strong>：使用阻塞 I/O 或执行某种类型的阻塞操作时，后台线程会等待这些操作的完成。使用线程，可以增强应用的设计，并且让处理阻塞的调用更加常见。</p><p>但是在执行多线程代码时，从一个线程的角度去看代码会不再有效，需要做一些有意义的假设。</p><p>理想情况下，每一个执行线程都相互独立，没有共享数据，这样并发编程没想象中复杂，编写的代码将会在一个独立的线程中执行。但在大多数情况下，会使用多个线程操作相同的数据，需要找到一种管控访问这些数据的方式，保证每一个对数据的操作都符合预期，不被其他线程操作造成不可预期行为。</p><p>并发编程需要编程语言和操作系统额外的保证，当多线程尝试同时改变变量（更多时候被称作”资源”）的值时候，需要一个显式状态信息来提供作用。</p><p>编程语言需要定义一个<em>内存模型</em>，在多线程存在的情况下，定义显式状态一些规则，指定这些基础状态在并发线程中如何运作，定义内存如何进行共享，以及指定那种方式的内存访问是有效的。</p><p>正因为如此，开发者对于每种语言中线程行为都有一个基本认知，只需要了解每种语言的编译器是如何在这个线程内存模型下去优化性能。</p><p>定义一个内存模型也是语言演化中一个重要的步骤，一个严格的模型将会限制编译器的演化。以前在内存模型的设计有可能会让新的优化搁浅。</p><p>定义内存模型的一些考虑点：</p><ul><li><p>语言表达式是否为<em>原子性</em>，在没有其他线程可以看到的情况下，操作将被整体执行。更有意义的场景是，一个变量是否被原子化操作。</p></li><li><p>多线程如何处理共享变量，变量被缓存是否是默认的，还有就是这个缓存行为是否受到特定的语言标识符所影响。</p></li><li><p>并发操作符通常被用作标记和管控共享资源的<em>临界区</em>和区域中的代码，允许有且只有一个线程同时执行指定的代码。</p></li></ul><p>接下来言归正传讨论如何在程序中使用并发。</p><p>正确处理并发的方式是，识别程序中的<em>临界区</em>，使用并发原语或者并发相关数据结构，来管控不同线程中的共享数据。</p><p>临界区中代码和数据结果的强制访问规则会带来一系列的其它问题，这些问题来源于一个事实，每一个将要执行的线程都期望得到自己想要的结果，都有机会修改共享数据，在某些情况下，这些线程中的一些线程永远不会执行，数据的修改也可能不按预期进行。</p><p>并发编程将面临一些额外的挑战，不得不去处理一些共同的问题：</p><ul><li><p><strong>竞争条件</strong>：当多线程操作同样的数据时，读和写数据同时进行，这一系列执行操作结果在不同的线程操作顺序下，变得不可预测。</p></li><li><p><strong>资源冲突</strong>：多线程会执行多个任务，需要安全的访问相同的资源时，将会增加额外的时间，这些延迟获取资源的时间，可能会导致不可预期的行为或者使得应用程序处理这些资源的数据结构变得复杂。</p></li><li><p><strong>死锁</strong>：多线程互相等待需要资源或锁的释放，然后永远阻塞这些线程的执行。</p></li><li><p><strong>饥饿</strong>：一个线程无法获取资源或者一个特定排序的资源，需要各种条件获取资源或者尝试获取资源永远失败。</p></li><li><p><strong>优先级反转</strong>：低优先级线程可能不断持有资源，需要这个资源的高优先级线程可能被其他不需要此资源的低优先级线程反转。</p></li><li><p>不可预期和公平：不能假设在什么时候或者什么顺序下，一个线程能获取到线程资源，延迟时间<a href="https://en.wikipedia.org/wiki/Unbounded_nondeterminism" target="_blank" rel="noopener">不会被优先级所决定</a>，但是会被冲突的数量所影响。一个线程不可能独立获得资源。但是并发原语用来保证临界区是<em>公平的</em>，或者说，为了<em>公平</em>，所有线程等待访问临界区的顺序都是依据等待顺序而来。</p></li></ul><p><a name="language_guarantees"></a></p><h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>虽然当前 Swift 还没有提供原生的并发编程特性，但它仍然提供了属性访问的多线程保证。</p><p>举个例子，全局变量就是被原子性的初始化的，不需要担心多线程情况下对同一变量的初始化操作，也不需要担心会看到一个初始化还在进行当中的部分初始化变量。</p><p>以上行为在下面实现单例模式的时候会看到。</p><p>但是需要重点注意的是，延迟属性初始化没有保证原子性，目前 Swift 语言没有提供注释或者修饰符来修改这种行为。</p><p>访问类变量同样没有保证原子性，如果想保证原子性，那么就需要提供额外的锁或者类似的机制来保证。</p><p><a name="threads"></a></p><h2 id="线程类"><a href="#线程类" class="headerlink" title="线程类"></a>线程类</h2><p><code>Foudation</code> 库提供了一个 <code>Thread</code> 类，内部继承自 <code>pthread</code>，可以用来创建线程和执行闭包。</p><p>使用 <code>Thread</code> 类的 <code>detachNewThreadSelector:toTarget:withObject:</code> 方法创建线程，或者自定义一个线程类，重写其中的 <code>main()</code> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread started, sleep for 2 seconds..."</span>)</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Done sleeping, exiting thread"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 iOS 10 和 macOS Sierra 开始，所有平台都可以使用构造器来创建一个新的线程，运行编写的闭包来指定线程执行。这篇文章所有例子仍然使用扩展基本 Thread 类，所以不需要担心是否是正确的操作系统来运行这些代码。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Started!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.stackSize = <span class="number">1024</span> * <span class="number">16</span></span><br><span class="line">t.start()               <span class="comment">//需要 100us 来生成一个线程</span></span><br></pre></td></tr></table></figure><p>一旦线程实例建立，需要手动的启动它。一个可选的步骤是，可以自定义新线程的栈空间大小。</p><p>可以调用<code>exit()</code>来终止线程，但这不推荐使用，因为这样不能保证当前任务能清理完成，大多数情况下，需要自己编写停止逻辑，或者使用<code>cancel()</code>方法，在主闭包中使用<code>isCancelled</code>属性来判断线程是否需要在自然结束之前终止当前任务。</p><p><a name="synchronization_primitives"></a></p><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>当有不同的线程同时想修改共享数据时，有必要使用某种方式来处理线程之间的同步问题，阻止数据混乱和不可预期的行为。<br>线程间同步基础的处理手段包括锁，信号量和监视器。<br>Foundation 库提供以上几种方式。</p><p>你会马上看到，在 Swift 3 中，这些类（是的，它们都是引用类型）并没有<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md#proposed-solution" target="_blank" rel="noopener">马上去掉 NS 前缀</a>，但是在未来的 Swift 版本中会去掉。</p><p><a name="nslock"></a></p><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><p><code>NSLock</code> 是 <code>Foundation</code> 提供的最基本的锁类型。</p><p>当一个线程尝试对一个对象进行加锁时，可能会发生两件事情，线程会在这个锁没有被其他线程持有时，获得这个锁，或者线程将阻塞，等到锁的拥有者释放锁。从另外个角度讲，锁只能同时被一个线程所持有，这种机制非常适合作用于临界区的监控访问。</p><p><code>NSLock</code> 和其它的 <code>Foundation</code> 中锁是不公平的，意味着当一些线程想获取锁时，不会按照它们访问锁的顺序来获取锁。</p><p>不能假设一个执行顺序，在一个高度线程冲突的环境中，当有许多线程尝试获取资源是，一些线程有可能会被置为饥饿，永远不能获取它们等待的锁（或者不能及时地获取资源）。</p><p>没有竞争的情况下，获取一个锁需要的时间是 100 纳秒，但是当超过一个线程尝试获取锁资源时，耗费的时间将迅速增长。所以从性能的角度来说，锁不是解决资源分配最好的方式。</p><p>来看看两个线程的例子，记住获取锁的顺序不是注定的，甚至有可能 t1 连续获得两次锁（但是这种情况比较少见）.</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lock = <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(id:<span class="type">Int</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.id = id</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock."</span>)</span><br><span class="line">        lock.unlock()</span><br><span class="line">        <span class="keyword">if</span> lock.<span class="keyword">try</span>() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired lock again."</span>)</span><br><span class="line">            lock.unlock()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">// If already locked move along.</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" couldn't acquire lock."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" exiting."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = <span class="type">LThread</span>(id:<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="type">LThread</span>(id:<span class="number">2</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>当决定使用锁机制时，需要附加一些警告。迟早会对并发程序进行调试，这种情况下，记得限制对一些需要排序数据结构去使用锁，在代码中尽量不在多个地方直接引用一个锁。</p><p>当调试一个并发问题时，检查有少量入口的同步数据结构的状态，要比随时关注锁在代码中的具体位置，并且需要记住在不同函数中锁状态来讲，要愉快的多。需要额外的工作，使得并发代码的结构更加合理。</p><p><a name="nsrecursivelock"></a></p><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a><code>NSRecursiveLock</code></h3><p>递归锁可以在一个线程已经持有这个锁的情况下，在后面的代码中获取多次，在递归函数和调用多个需要顺序检查同一个锁的函数时，需要用到这种锁。递归锁和基本锁<strong>不能共用</strong>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rlock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rlock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</span><br><span class="line">        callMe()</span><br><span class="line">        rlock.unlock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Exiting main"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rlock.lock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Thread acquired lock"</span>)</span><br><span class="line">        rlock.unlock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Exiting callMe"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr = <span class="type">RThread</span>()</span><br><span class="line">tr.start()</span><br></pre></td></tr></table></figure><p><a name="nsconditionlock"></a></p><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><p>条件锁提供了附加的子锁，子锁可以独立地被加锁和被解锁，用来支持复杂的加锁步骤（比如：消费者-提供者场景）。</p><p>同时可以用一个全局锁（不管什么具体的场景都可以加锁），这种锁的行为和经典的 NSLock 一样。</p><p>下面的例子使用一个条件锁来保护共享整型，提供者每次更新整型，消费者都会在终端打印整型。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">NO_DATA</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">GOT_DATA</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> clock = <span class="type">NSConditionLock</span>(condition: <span class="type">NO_DATA</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="type">SharedInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            clock.lock(whenCondition: <span class="type">NO_DATA</span>) <span class="comment">//当条件为 NO_DATA 获取该锁</span></span><br><span class="line">  <span class="comment">// 如果不想等待消费者，直接调用 clock.lock() 即可</span></span><br><span class="line">            <span class="type">SharedInt</span> = i</span><br><span class="line">            clock.unlock(withCondition: <span class="type">GOT_DATA</span>) <span class="comment">//解锁并设置条件为 GOT_DATA</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            clock.lock(whenCondition: <span class="type">GOT_DATA</span>) <span class="comment">// 当条件为 GOT_DATA 获取该锁</span></span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            clock.unlock(withCondition: <span class="type">NO_DATA</span>) <span class="comment">//解锁并设置条件为 NO_DATA</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pt = <span class="type">ProducerThread</span>()</span><br><span class="line"><span class="keyword">let</span> ct = <span class="type">ConsumerThread</span>()</span><br><span class="line">ct.start()</span><br><span class="line">pt.start()</span><br></pre></td></tr></table></figure><p>当创建一个条件锁时，需要使用一个整型指定开始条件。</p><p><code>lock(whenCondition:)</code>方法在条件成立的情况下获得一个锁，或者等待另外一个线程使用<code>unlock(withCondition:)</code>释放锁并且设置这个值。</p><p>条件锁对于基本锁的一些小的改进允许我们建模更加复杂的场景。</p><p><a name="nscondition"></a></p><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a><code>NSCondition</code></h3><p>不要混淆了 NSCondition 和条件锁，一个条件提供了更加清晰的等待<em>条件</em>产生的方式。</p><p>当一个已经获得锁的线程需要验证额外的条件（一些需要的资源，一个处于特殊状态的对象等），满足条件才能继续运行的时候，需要一种方式挂起然后在条件成立的时候继续工作。</p><p>在没有 NSCondition 的时候，这种情况通常会被实现为连续地或者周期性地检查条件（繁忙的等待），但是这样的话，线程获取的锁将会怎样？当条件成立希望再次获取他们之前，是应该等待还是释放它们呢？</p><p>NSCondition 提供了一个此问题清晰的解决方案，拥有此锁的线程会将此条件加入了<em>等待</em>列表，当条件成立时，通过另外一个线程的信号唤醒此线程。</p><p>下面是一个例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cond = <span class="type">NSCondition</span>()</span><br><span class="line"><span class="keyword">var</span> available = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">SharedString</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            cond.lock()</span><br><span class="line">            <span class="type">SharedString</span> = <span class="string">"😅"</span></span><br><span class="line">            available = <span class="literal">true</span></span><br><span class="line">            cond.signal() <span class="comment">// 通知并且唤醒等待的线程</span></span><br><span class="line">            cond.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterThread</span> : <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123; <span class="comment">// 循环 5 次</span></span><br><span class="line">            cond.lock()</span><br><span class="line">            <span class="keyword">while</span>(!available)&#123;   <span class="comment">// 通过伪信号进行保护</span></span><br><span class="line">                cond.wait()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="type">SharedString</span>)</span><br><span class="line">            <span class="type">SharedString</span> = <span class="string">""</span></span><br><span class="line">            available = <span class="literal">false</span></span><br><span class="line">            cond.unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> writet = <span class="type">WriterThread</span>()</span><br><span class="line"><span class="keyword">let</span> printt = <span class="type">PrinterThread</span>()</span><br><span class="line">printt.start()</span><br><span class="line">writet.start()</span><br></pre></td></tr></table></figure><p><a name="nsdistributedlock"></a></p><h3 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a><code>NSDistributedLock</code></h3><p>分布式锁和之前看到的锁机制完全不同，我不希望大家会频繁的使用它。</p><p>此锁的目标是在多个应用中共享数据，背后是是用一个文件系统的入口（比如一个简单的文件）。这意味着所有需要用到的应用都应该可以访问这个文件系统。<br>使用<code>try()</code>方法来获取锁，这是一个非阻塞的方法，立即会返回一个布尔值来表明是否获取到了锁。获取锁的尝试通常是多次，通常在尝试成功之前都会加上一个合理的延迟。<br>使用<code>unlock()</code>方法来释放一个分布式锁。<br>接下来是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dlock = <span class="type">NSDistributedLock</span>(path: <span class="string">"/tmp/MYAPP.lock"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dlock = dlock &#123;</span><br><span class="line">    <span class="keyword">var</span> acquired = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!acquired)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Trying to acquire the lock..."</span>)</span><br><span class="line">        usleep(<span class="number">1000</span>)</span><br><span class="line">        acquired = dlock.<span class="keyword">try</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line"></span><br><span class="line">    dlock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="osatomic_where_art_thou"></a></p><h3 id="OSAtomic-还能用吗？"><a href="#OSAtomic-还能用吗？" class="headerlink" title="OSAtomic 还能用吗？"></a><code>OSAtomic</code> 还能用吗？</h3><p><a href="[mikeash.com: Friday Q&amp;A 2011-03-04: A Tour of OSAtomic](https://www.mikeash.com/pyblog/friday-qa-2011-03-04-a-tour-of-osatomic.html">OSAtomic</a>) 提供的原子操作，都是一些简单的操作，没有使用经典锁逻辑，允许 set，get 或者 比较后 set 变量的操作，因为 OSAtomic 考虑到了具体的 CPU 功能（一些原生原子操作），比上面的锁机制提供更好的性能。</p><p>因为它处理并发的方式比较原始，所以不能说它们在构建并发数据结构时候非常有用。</p><p>从 macOS 10.12 开始，OSAtomic 被淘汰，并且它从来不能在 Linux 下使用，但是一些开源库，比如<a href="[GitHub - glessard/swift-atomics: Atomic operations bridged from Clang to Swift](https://github.com/glessard/swift-atomics">这个库</a>)提供了有用的 Swift 扩展，还有<a href="https://github.com/bignerdranch/AtomicSwift" target="_blank" rel="noopener">这个库</a>提供类似的功能，你也可以通过最新 <a href="[GitHub - macmade/AtomicKit: Concurrency made simple in Swift.](https://github.com/macmade/AtomicKit">AtomicKit 库</a>)得到类似的功能。</p><p><a name="on_synchronized_blocks"></a></p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在 Swift 中，不能像 Objective-C 创建一个 @synchronized 块那样去做并发操作，Swift 中没有对应可用的关键字。</p><p>在 Darwin 系统下，可以使用 <code>objc_sync_enter(OBJ)</code> 和 <code>objc_sync_exit(OBJ)</code>实现 @ synchronized 类似的功能，并且存在一个 @objc 的对象监控器。这种方式不推荐使用，还是使用更简单的锁机制来实现并发，更加有效。</p><p>正如接下来讨论 Dispatch Queues 时候会看到的那样，使用队列来实现类似的功能，在一个序列队列里面使用少量代码操作一个同步调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serialQueue.sync &#123;</span><br><span class="line">    // 同时只有一个线程执行 </span><br><span class="line">    v += 1</span><br><span class="line">    print(&quot;Current value \(v)&quot;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="grand_central_dispatch"></a></p><h2 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD: Grand Central Dispatch"></a><code>GCD: Grand Central Dispatch</code></h2><p>对于那些还对此 API 不熟悉的人来讲，Grand Central Dispatch (GCD) 其实就是一个基于队列的 API，允许你在工作池中执行闭包。</p><p>也就是说，闭包包含需要执行的任务，然后闭包将会被添加到队列中，队列将会使用一系列串行或者并行的线程执行它们，串行或并行执行取决于队列的配置选项。但是不管是那种类型的队列，任务的执行都遵从 FIFO 原则，意味着任务的执行顺序都会按照进入的顺序进行，完工时间取决于每个任务的持续时间。</p><p>这是一个通用的处理并发的模式，在每一个现代语言的运行时中都会看到。线程池是一种简单的方式，管理，查看和控制一系列的空闲或者未连接的线程。</p><p>GCD API 在 Swift 3 有少量的修改， <a href="[swift-evolution/0088-libdispatch-for-swift3.md at master · apple/swift-evolution · GitHub](https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md">SE-0088</a>) 优化了设计，让 API 变得面向对象。</p><p><a name="dispatch_queues"></a></p><h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>GCD 允许创建自定义队列，同时也提供访问预先定义好的系统队列的方式。</p><p>创建一个基本的串行队列，只需要提供一个字符串标签参数来识别它，通常推荐使用一个反向排序的域名前缀，用于在栈序列中查找队列的主人。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Serial1"</span>)  <span class="comment">//attributes: .serial</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent1"</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>第二个队列是并行队列，意味着这个队列使用线程中的可用线程来执行它包含的任务。在这种情况下，执行的顺序不可预测，不要假设闭包的完成顺序和插入顺序有任何的联系。</p><p>默认的队列可以使用 <code>DispatchQueue</code> 来获取：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = <span class="type">DispatchQueue</span>.main</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globalDefault = <span class="type">DispatchQueue</span>.global()</span><br></pre></td></tr></table></figure><p>主队列是一个顺序执行的队列，用于处理 iOS 和 macOS 可视化应用中的主事件循环，响应事件并且更新用户界面。众所周知，每一个对于用于界面的修改都将会在此队列中执行，每一个长时间的操作都会在此线程中绘制用户界面，这样用户界面会响应不及时。</p><p>运行时也提供了不同的优先级区分访问其他全局队列的方式，通过指定 <code>Quality of Service (Qos)</code>  参数来实现。</p><p>不同级别的优先级定义在 <code>DispatchQoS</code>类（译者注：DispatchQoS 是一个结构体，内含一个枚举类型表示优先级）中，从高到低如下：</p><ul><li>.userInteractive</li><li>.userInitiated</li><li>.default</li><li>.utility</li><li>.background</li><li>.unspecified</li></ul><p>需要重点注意的是，在手机设备上，提供低电量模式，在低电量情况下，<a href="https://mjtsai.com/blog/2017/04/03/beware-default-qos/" target="_blank" rel="noopener">后台队列会被挂起</a>。</p><p>为了获取一个特定优先级的全局队列，使用 <code>global(qos:)</code>指定需要的优先级：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>.global(qos: .background)</span><br></pre></td></tr></table></figure><p>同样的优先级指定符可以用来创建自定义队列：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueueHighPriority = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.SerialH"</span>, qos: .userInteractive)</span><br></pre></td></tr></table></figure><p><a name="using_queues"></a></p><h3 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h3><p>任务以闭包的方式存在，可以使用两种方式将任务提交到队列中：<br>使用<code>sync</code>方法进行<em>同步操作</em>，或者使用<code>async</code>方法进行<em>异步操作</em>。</p><p>当使用前者时，<code>sync</code>调用将会被阻塞，换句话说，当闭包完成时，<code>sync</code>方法才会完成（当需要等待闭包完成情况下，这种方式是有效的，但是有更好的方法），而前者会将闭包加入到队列中，安排闭包延迟执行，并且允许当前的函数继续执行。</p><p>下面是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Async on MainQ, first?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalDefault.sync &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Sync in MainQ, second?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个分发的调用可能会被嵌套，在一个设定好的队列上执行后台的，低优先级的操作，然后需要更新主队列的用户界面。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">    <span class="comment">// 后台运行的代码放在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="comment">// 更新主界面</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"UI updated on main queue"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包可以在指定延迟时间后执行，Swift 3 提供了简便的方式来指定需要的时间间隔，使用 <code>DispatchTimeInterval</code>枚举中的 4 个时间单位来组合不同的时间间隔：<code>.seconds(Int)</code>, <code>.milliseconds(Int),</code> <code>.microseconds(Int)</code>和 <code>.nanoseconds(Int)</code>.</p><p>使用 <code>asyncAfter(deadline:execute:)</code>带有一个时间间隔参数来计划一个未来执行的闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.asyncAfter(deadline: .now() + .seconds(<span class="number">5</span>)) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"After 5 seconds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想同时执行一个相同的闭包多次（类似于使用 <em>dispatch_apply</em>的那样），可以使用<code>concurrentPerform(iterations:execute:)</code>来实现，需要注意的是，这些闭包可能会在当前的队列中并行执行，所以请记住把这个调用的方法包含在一个支持并发队列的同步和异步调用中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">globalDefault.sync &#123;  </span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span> times"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While normally a queue is ready to process its closures upon creation, it can be configured to start in an idle state and to start processing jobs only when manually enabled.<br>通常一个队列在创建后就会执行它的闭包，但是也可以手动的启动任务：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inactiveQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.inactiveQueue"</span>, attributes: [.concurrent, .initiallyInactive])</span><br><span class="line">inactiveQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Not yet..."</span>)</span><br><span class="line">inactiveQueue.activate()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Gone!"</span>)</span><br></pre></td></tr></table></figure><p>这是第一次需要指定多个属性的情况，正如代码所示，可以使用数组来添加多个属性。</p><p>任务可以使用继承自 <code>DispatchObject</code> 的方法来挂起或者恢复任务的执行：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">inactiveQueue.suspend()</span><br><span class="line"></span><br><span class="line">inactiveQueue.resume()</span><br></pre></td></tr></table></figure><p><code>setTarget(queue:)</code> 方法可以用来配置非活跃队列的优先级（使用它来设置活跃队列将导致崩溃），调用此方法，把队列的优先级设置为作为参数传入队列的优先级。</p><p><a name="barriers"></a></p><h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>在添加一系列闭包到指定的队列中（在不同的间隔）之后，这时想在所有异步任务完成之后执行一个任务。就需要使用屏障(Barriers)来做事。</p><p>添加 20 个（译者注：代码里面是 5 个）任务（每个任务将休眠一秒钟再执行）到之前创建的并发队列中，使用屏障在所有任务完成时打印一些东西，在最后一个 async 调用时候指定一个 <code>DispatchWorkItemFlags.barrier</code> 标识：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.uraimo.Concurrent"</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123; </span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">5</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Async on concurrentQueue, 5 times: "</span>+<span class="type">String</span>(id))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">concurrentQueue.async (flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All 5 concurrent tasks completed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>20 个任务将会并行乱序执行，可以看到打印消息会成组出现，打印数量是 Mac 系统的执行内核的个数，但是最后一个调用将会在最后执行。</p><p>屏障还被用于强制指定并发队列的执行顺序，不想让那些已经注册任务的执行按照一个重复的方式进行。</p><p>正如 Arthur Hammer 注明的那样，分发屏障不能作用与串行队列或者任何一种类型的<a href="[dispatch_barrier_async - Dispatch | Apple Developer Documentation](https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async?language=objc">全局并行队列</a>)，如果你想使用它，就必须自定义一个全新的并行队列。</p><p><a name="singletons_and_dispatch_once"></a></p><h3 id="单例和-Dispatch-once"><a href="#单例和-Dispatch-once" class="headerlink" title="单例和 Dispatch_once"></a>单例和 Dispatch_once</h3><p>众所周知，Swift 3 中已经没有了<code>dispatch_once</code>, 这个函数常用于构建线程安全的单例。</p><p>幸运的是，Swift 确保使用原子化的方式进行全局变量初始化，如果你确认常量不会在初始化后改变它的值，这两个特征确保全局常量是一个很好的实现单例的方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance: <span class="type">Singleton</span> = <span class="type">Singleton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加类的<code>final</code>修饰确保没有子类可以继承它，并且把指定构造器设置为私有，这样就没有可能通过其他方式手动创建这个类的实例了。全局静态常量将会是 Singleton 唯一访问入口，用于获取单独的，共享的实例。</p><p>类似的行为用在定义块中，以下代码将执行一次：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runMe</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> i: () = &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Once!"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Inner</span>.i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runMe()</span><br><span class="line">runMe() <span class="comment">// 常量已经被初始化了</span></span><br><span class="line">runMe() <span class="comment">// 常量已经被初始化了</span></span><br></pre></td></tr></table></figure><p>看起来不是那么优雅，但是能够运行，这是一种可以接受的实现方式，如果只是想执行一次性代码的话。</p><p>But if we need to replicate exactly the functionality and API of dispatch_once we need to implement it from scratch, as described in the synchronized blocks section with an extension:<br>如果想重现 <code>dispatch_once</code> 所提供的功能，需要重新实现，使用一个扩展在<a href="#on_synchronized_blocks">同步模块区域</a>添加代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">DispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> onceTokens = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> internalQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"dispatchqueue.once"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">once</span>(<span class="title">token</span>: <span class="title">Int</span>, <span class="title">closure</span>: (<span class="title">Void</span>)-&gt;<span class="title">Void</span>) </span>&#123;</span><br><span class="line">        internalQueue.sync &#123;</span><br><span class="line">            <span class="keyword">if</span> onceTokens.<span class="built_in">contains</span>(token) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                onceTokens.append(token)</span><br><span class="line">            &#125;</span><br><span class="line">            closure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="number">1</span></span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"only once!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Two times!?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.once(token: t) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Three times!!?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所愿，三个闭包中的第一个将会被真正的执行。</p><p><a name="dispatch_groups"></a></p><h3 id="调度组"><a href="#调度组" class="headerlink" title="调度组"></a>调度组</h3><p>如果你有多个任务，想添加到多个不同的队列中，并且想等待它们的完工，你可以把它们进行分组，添加到一个调度组中。</p><p>Let’s see an example, a task can be added to a specific group directly with the sync or async call:<br>下面是一个例子，直接使用 <code>sync</code> 或者 <code>async</code> 调用将一个任务添加到一个指定的组中：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mygroup = <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    globalDefault.async(group: mygroup)&#123;</span><br><span class="line">        sleep(<span class="type">UInt32</span>(i))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Group async on globalDefault:"</span>+<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务将在 <code>globalDefault</code> 里面执行，但是可以注册一个 <code>mygroup</code> 的回调，一旦所有任务完成以后，将会在队列中执行一个闭包，<code>wait()</code>方法用于执行阻塞等待。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Waiting for completion..."</span>)</span><br><span class="line">mygroup.notify(queue: globalDefault) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Notify received, done waiting."</span>)</span><br><span class="line">&#125;</span><br><span class="line">mygroup.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</span><br></pre></td></tr></table></figure><p>另外一种跟踪组任务方式是，手动在运行队列代码调用中进入和离开一个组，替换指定的方式：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    mygroup.enter()</span><br><span class="line">    sleep(<span class="type">UInt32</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Group sync on MAINQ:"</span>+<span class="type">String</span>(i))</span><br><span class="line">    mygroup.leave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dispatch_work_items"></a></p><h3 id="调度工作项"><a href="#调度工作项" class="headerlink" title="调度工作项"></a>调度工作项</h3><p>闭包不是队列中指定任务实现的唯一方式，有时可能需要一个容器类型来跟踪执行的状态，这个时候 <code>DispatchWorkItem</code> 就派上了用场，工作项的每一个方法，都包括一个闭包作为它的参数。</p><p>工作项封装了一个队列线程池执行的闭包，通过 perform()  来执行这个闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workItem.perform()</span><br></pre></td></tr></table></figure><p><code>DispatchWorkItem</code> 同样提供其它有用的方法，比如: 和组的定义一样，<code>notify</code>方法将会在指定的队列执行完成以后执行一个闭包：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">workItem.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Notify on Main Queue!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defaultQueue.async(execute: workItem)</span><br></pre></td></tr></table></figure><p>也可以等待闭包执行结束，或者在队列尝试调用<code>cancel()</code>方法（这不是取消执行中的闭包）之前标记它删除。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Waiting for work item..."</span>)</span><br><span class="line">workItem.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done waiting."</span>)</span><br><span class="line">workItem.cancel()</span><br></pre></td></tr></table></figure><p>需要重点注意的是，<code>wait()</code>方法不仅仅是阻塞当前线程，等待完成，也会抬高所有队列中早先的工作项，试图尽快完成指定的项目。</p><p><a name="dispatch_semaphores"></a></p><h3 id="调度信号量"><a href="#调度信号量" class="headerlink" title="调度信号量"></a>调度信号量</h3><p>调度信号量是一种锁，根据当前计数的值，可以被多个线程获取。</p><p>线程会等待一个信号量，直到信号量减到 0 时，就可以获取它了。</p><p>访问信号量的槽将对等待线程释放，等待线程调用<code>signal</code>方法将会增加计数。</p><p>下面是一个简单的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sem = <span class="type">DispatchSemaphore</span>(value: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量将被两个线程池组持有</span></span><br><span class="line">globalDefault.sync &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.concurrentPerform(iterations: <span class="number">10</span>) &#123; (id:<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">        sem.wait(timeout: <span class="type">DispatchTime</span>.distantFuture)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(id)+<span class="string">" acquired semaphore."</span>)</span><br><span class="line">        sem.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dispatch_assertions"></a></p><h3 id="调度断言"><a href="#调度断言" class="headerlink" title="调度断言"></a>调度断言</h3><p>Swift 3 引入了一个新的函数，用于在当前执行上下文中进行断言，用于验证一个闭包是否在预期的队列中被执行了。使用 <code>DispatchPredicate</code> 枚举的是三个值来断言执行的情况：<code>.onQueue</code>, 验证闭包是否执行在一个指定队列中，<code>.notOnQueue</code>, 验证相反的情况，<code>.onQueueAsBarrier</code>，验证当前闭包或者工作项是否作为一个队列的屏障存在。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatchPrecondition(condition: .notOnQueue(mainQueue))</span><br><span class="line">dispatchPrecondition(condition: .onQueue(queue))</span><br></pre></td></tr></table></figure><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。  </p></blockquote><p><a name="dispatch_sources"></a></p><h2 id="调度资源"><a href="#调度资源" class="headerlink" title="调度资源"></a>调度资源</h2><p>调度资源是一种处理系统级异步事件的方式，包括内核信号，系统，文件或者 socket 相关使用事件处理的事件。</p><p>有以下几种类型可用的调度资源，归类如下：</p><ul><li><strong>Timer Dispatch Sources</strong> : 用作产生与时间或者周期相关的事件（DispatchSourceTimer）。<br><strong>Signal Dispatch Sources</strong> : 用于处理 UNIX 信号（DispatchSourceSignal）。<br><strong>Memory Dispatch Sources</strong>:<br>用于注册与内存使用状态相关的通知（DispatchSourceMemoryPressure）。<br><strong>Descriptor Dispatch Sources</strong>:<br>用于注册文件和socket相关的不同事件（DispatchSourceFileSystemObject, DispatchSourceRead, DispatchSourceWrite）。<br><strong>Process dispatch sources</strong>:<br>用于监控外部进程相关执行状态的时间（DispatchSourceProcess）。<br><strong>Mach related dispatch sources</strong>:<br>用于处理 Mach 内核的 <a href="http://fdiv.net/2011/01/14/machportt-inter-process-communication" target="_blank" rel="noopener">IPC 工具</a>相关的事件（<em>DispatchSourceMachReceive</em>, <em>DispatchSourceMachSend</em>）。</li></ul><p>也可以在需要的时候自定义调度资源。所有的调度资源都遵从<code>DispatchSourceProtocol</code> 协议，需要定义注册处理器的基本操作，修改调度资源的激活状态等。</p><p>举一个 <code>DispatchSourceTimer</code> 的例子来理解如何使用这些对象。</p><p>使用 <code>DispatchSource</code> 的工具函数来创建资源对象，在下面代码中使用 <code>makeTimerSource</code>， 指定需要执行处理的调度队列。</p><p>时间资源没有其它参数，只需要指定队列来创建资源，调度资源可以处理多个时间，通常需要指定处理事件的标识符。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="type">DispatchSource</span>.makeTimerSource(queue: <span class="type">DispatchQueue</span>.global())</span><br><span class="line">t.setEventHandler&#123; <span class="built_in">print</span>(<span class="string">"!"</span>) &#125;</span><br><span class="line">t.scheduleOneshot(deadline: .now() + .seconds(<span class="number">5</span>), leeway: .nanoseconds(<span class="number">0</span>))</span><br><span class="line">t.activate()</span><br></pre></td></tr></table></figure><p>资源建立以后，使用<code>setEventHandler(closure:)</code>注册一个时间处理器，如果没有其它配置了，使用<code>activate()</code>开启调度资源（前一个版本的<code>libDispatch</code> 使用的是 <code>resume()</code>方法）。</p><p>调度资源初始是不激活的，意味着不会立刻执行事件。当一切准备情绪后，资源将使用<code>activate()</code>激活分发事件，也可以使用<code>suspend()</code>挂起和使用<code>resume()</code>恢复。</p><p>时间资源需要一个额外的步骤来配置哪种类型的时间事件会被对象调度。在下面的例子中，定义一个会在 5 秒后执行的调度事件。</p><p>也可以定义一个周期事件，和在 <a href="https://www.uraimo.com/swiftbites/nstimer-in-swift-3/" target="_blank" rel="noopener">Timer</a> 对象所做的一样：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">t.scheduleRepeating(deadline: .now(), interval: .seconds(<span class="number">5</span>), leeway: .seconds(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>当完成一个调度资源时，想完全阻止调度事件，可以使用<code>cancel()</code>来完成，这样可以停止资源事件，取消已经设置的处理器，并且进行一些清理操作，比如注销处理器等。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">t.cancel()</span><br></pre></td></tr></table></figure><p>其它调度资源类型的 API 是类似的，看一个 <a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L96" target="_blank" rel="noopener">Kitura</a> 初始化读取资源的例子，用于处理在一个建立连接的 socket 的异步写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">readerSource = <span class="type">DispatchSource</span>.makeReadSource(fileDescriptor: socket.socketfd,</span><br><span class="line">                                             queue: socketReaderQueue(fd: socket.socketfd))</span><br><span class="line"></span><br><span class="line">readerSource.setEventHandler() &#123;</span><br><span class="line">    <span class="number">_</span> = <span class="keyword">self</span>.handleRead()</span><br><span class="line">&#125;</span><br><span class="line">readerSource.setCancelHandler(handler: <span class="keyword">self</span>.handleCancel)</span><br><span class="line">readerSource.resume()</span><br></pre></td></tr></table></figure><p>当 socket 中接收数据缓存中有新的字节可用时， <code>handleRead()</code> 将在一个专用的队列中调用。Kitura 同样使用 <code>WriteSource</code> 来操作一个缓存写，使用分发资源事件进行<a href="https://github.com/IBM-Swift/Kitura-net/blob/master/Sources/KituraNet/IncomingSocketHandler.swift#L328" target="_blank" rel="noopener">高效的写操作</a>，当 socket 管道可以发送字节时，就写入新的字节。在 *nix 平台下去进行 I/O 操作，调度资源是一个很好的高阶方案，替代那些底层的 API。</p><p>对于和文件相关的调度资源，另外一个有用的对象是 <code>DispatchSourceFileSystemObject</code>， 它允许监听指定文件的变化，从名字的变化到属性的变化都可以监听。使用调度资源，你也可以接受文件修改或者删除的通知，这是 Linux 中 inotify 内核子系统的一个子集。</p><p>剩余的资源类型操作是类似的，你可以从 <a href="https://developer.apple.com/reference/dispatch/dispatchsource" target="_blank" rel="noopener">libDispatch 文档</a>中获取更多的细节，但是请记住的是，像 <code>Mach</code> 资源和内存压力资源只能在 <code>Darwin</code> 平台中使用。</p><p><a name="operations_and_operationqueues"></a></p><h3 id="操作和操作队列"><a href="#操作和操作队列" class="headerlink" title="操作和操作队列"></a>操作和操作队列</h3><p>简单来说说操作队列，这是建立在 GCD 顶层的附加 API，把并行队列和模型任务看作为操作，易于取消，依赖其它操作完成情况来执行任务。</p><p>操作可以有优先级，定义了执行的顺序，也可以添加到 <code>OperationQueues</code> 异步执行。</p><p>看看一个基本的例子：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line">queue.name = <span class="string">"My Custom Queue"</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mainqueue = <span class="type">OperationQueue</span>.main <span class="comment">// 引用主线程中的队列</span></span><br><span class="line"></span><br><span class="line">queue.addOperation&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">queue.addOperation&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以创建一个<em>阻塞操作</em>对象，在添加到队列之前进行配置，并且可以添加多个闭包到这个类型的操作中。</p><p>需要注意的是，在 Swift 中， <code>NSInvocationOperation</code>, 不再可用，这个类可以使用<br><code>target+selector</code> 来创建操作。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> op3 = <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op3"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">op3.queuePriority = .veryHigh</span><br><span class="line">op3.completionBlock = &#123;</span><br><span class="line">    <span class="keyword">if</span> op3.isCancelled &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Someone cancelled me."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Completed Op3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> op4 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Op4 always after Op3"</span>)</span><br><span class="line">    <span class="type">OperationQueue</span>.main.addOperation&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I'm on main queue!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作会有优先级，第二个完整的闭包将在主闭包完成后执行一次。</p><p>还可以添加 <code>op4</code> 对 <code>op3</code> 的依赖，这样 <code>op4</code> 将等待 <code>op3</code> 的完成。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">op4.addDependency(op3)</span><br><span class="line">queue.addOperation(op4)  <span class="comment">// op3 会一直在 op4 之前执行</span></span><br><span class="line">queue.addOperation(op3)</span><br></pre></td></tr></table></figure><p>也可以使用 <code>removeDependency(operation:)</code> 移除依赖，依赖是存储在一个公开访问的依赖数组中。</p><p>操作的状态可以使用指定的属性查看：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">op3.isReady       <span class="comment">// 是否准备好执行？</span></span><br><span class="line">op3.isExecuting   <span class="comment">// 是否执行中？</span></span><br><span class="line">op3.isFinished    <span class="comment">// 是否执行完成或被取消掉？</span></span><br><span class="line">op3.isCancelled    <span class="comment">// 是否被手动取消？</span></span><br></pre></td></tr></table></figure><p>调用 <code>cancelAllOperations</code> 可以取消一个现存队列中所有的操作，在队列中存在的所有操作都会被设置 <code>isCancelled</code> 标识。调用 cancel 方法可以取消单个操作：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.cancelAllOperations() </span><br><span class="line">op3.cancel()</span><br></pre></td></tr></table></figure><p>推荐执行时对 <code>isCancelled</code> 属性进行检查，当计划在队列中执行这个操作时，一旦操作被取消，可以检查<code>isCancelled</code>来跳过这个执行。</p><p>最后，可以在操作队列中停止新操作的执行（当前执行中的操作不会被影响）：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.isSuspended = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>此文章和本博客相关文章代码可以从 <a href="https://github.com/uraimo/Swift-Playgrounds" target="_blank" rel="noopener">GitHub</a>和 <a href="https://www.uraimo.com/archives/2017-05-07-ConcurrencyInSwift.playground.zip" target="_blank" rel="noopener">Zipped</a>上下载。  </p></blockquote><p><a name="closing_thoughts"></a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这篇文章很好的总结了 Swift 中目前可用的外部并发框架。</p><p>即将到来的此系列第二部分将聚焦在如何在不引入外部库的情况下，使用原生语言特性来处理并发。借助现有的一些开源实现，介绍一些有趣的范式。</p><p>我希望这两篇文章是一个打开并发编程之门的很好的介绍，这将有助于理解和参与在 swift-evolution 中的讨论，至于何时会引入原生的支持，希望是 Swift 5吧。</p><p>查看更多关于 Swift 和并发有趣的故事，可以查看博客：<a href="https://www.cocoawithlove.com/tags/asynchrony.html" target="_blank" rel="noopener">Cocoa With Love</a>。</p><p>喜欢这篇文章吗？给我 <a href="https://www.twitter.com/uraimo" target="_blank" rel="noopener">twitter</a> 留言吧！</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Umberto Raimondi，&lt;a href=&quot;https://www.uraimo.com/2017/05/07/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-05-07&lt;br&gt;译者：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；校对：&lt;a href=&quot;http://codebuild.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shanks&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;当前最新版本的 Swift 语言（译者注：当前最新稳定版本为 3.1.1）还没有包含任何原生并发特性，但是在其他现代编程语言中是带有这个特性的，比如 Go 和 Rust。&lt;br&gt;如果你想并发地执行任务，这时就需要处理与结果相关的竞态条件，目前唯一的选择就是使用第三方库，比如 libDispatch，或者 Foundation 和其他 OS 中提供的同步原语。&lt;br&gt;在这一系列文章的第一部分，看看 Swift 3 给出的处理方案，覆盖以下一些内容：Foundation 中的锁，线程和计时器提供语言层面的保证，最近不断增强的 GCD(Grand Central Dispatch) 和操作队列（Operation Queues）。&lt;/p&gt;
&lt;p&gt;同时也会讨论到基础的并发原理和一些通用的并发模式。&lt;/p&gt;
    
    </summary>
    
      <category term="uraimo" scheme="https://swift.gg/categories/uraimo/"/>
    
    
      <category term="Swift 进阶，并发编程" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于 Purple Train 的说明</title>
    <link href="https://swift.gg/2017/07/31/announcing-purple-train/"/>
    <id>https://swift.gg/2017/07/31/announcing-purple-train/</id>
    <published>2017-07-31T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Ian C. Anderson，<a href="https://robots.thoughtbot.com/announcing-purple-train" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-1-9<br>译者：<a href="undefined">Tuccuay</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>我一直想开发一个 iOS 应用，现在我可以很高兴的告诉大家，在许多同事的帮助下终于在今年完成了 <a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a>。</p><p><img src="/img/articles/announcing-purple-train/TujwAPQD6B8G2RoVixXA_purple-train-iphone-app-f7b427aaec509ee65069d07f2e809152.png1501462197.36" alt=""></p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Purple Train 为了解决一个简单的问题：我关心的下一趟 MBTA 通勤火车什么时候出发？市场上几个类似的 app 都感觉不太好用。我只想很快速的打开它并得到想要的信息，然后返回。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>如果你想从一个固定的「家」和波士顿之间通勤，这个应用能为你提供一个简单而有效的界面：选择你家附近的车站，然后就能离开看到往返于波士顿之间的列车。如果有快车不在选择的车站停车，它将会被自动过滤掉以免带来不必要的干扰。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>在开始开发 app 之前，有不少人讲过 React Native 的优点，所以我尝试了一下。我感兴趣的原因并不是因为能使用 JavaScript 开发，而是因为它能够进行 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="noopener">跨平台开发</a>。我已经很熟悉使用 React 和 Redux 进行函数式响应式编程。所以想在 Purple Train 上尝试一下看看它带来多大生产力的提升。</p><p><a href="https://twitter.com/twnsndco" target="_blank" rel="noopener">Cole Townsend</a> 在完成 app 的初期设计工作的时候觉得非常舒服，他使用 React Native 的 <a href="https://facebook.github.io/react-native/docs/stylesheet.html" target="_blank" rel="noopener">StyleSheet</a> 来实现这些设计。</p><p>基本功能在 iOS 上正常运行之后，<a href="https://twitter.com/kenyonj" target="_blank" rel="noopener">Justin Kenyon</a> 和我花了半天时间把它移植到 Android。让我们感到高兴的是这个过程很简单，并且整个 app 中没有针对某个特定平台的兼容代码，在所有的工作中只用到了 React Native 和几个第三方库。</p><p>感谢 <a href="https://twitter.com/blakewilliams__" target="_blank" rel="noopener">Blake Williams</a>, <a href="https://twitter.com/kenyonj" target="_blank" rel="noopener">Justin Kenyon</a>, <a href="https://twitter.com/derekprior" target="_blank" rel="noopener">Derek Prior</a>, and <a href="https://twitter.com/mborsare" target="_blank" rel="noopener">Mike Borsare</a> 所做的前端工作！</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>这个 app 的后端是一个 Elixir Phoenix 应用，用于缓存 <a href="http://realtime.mbta.com/portal" target="_blank" rel="noopener">MBTA’s Realtime API</a> 的响应并且能够返回针对移动应用优化过的更精简的 JSON。</p><p>这个 Phoenix 使用 Elixir 提供的 <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html" target="_blank" rel="noopener">Agent</a> 模块存储来自 MBTA API 的响应。这让我们有了一个非常迅速的内存缓存，使得后端能够快速响应。</p><p>后端还有一些可以过滤掉用户不关心的车次（比如已经离开用户所在车站或者不停靠用户所在站点的快车）的功能。这使得前端的工作更方便并且保持较小的 JSON 响应，这也有助于提升移动设备的性能。</p><p>感谢 <a href="https://twitter.com/derekprior" target="_blank" rel="noopener">Derek Prior</a> 和 <a href="https://twitter.com/joshuaclayton" target="_blank" rel="noopener">Josh Clayton</a> 编写并优化的后端！</p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>Web 开发工程师和设计师都可以立即开始使用 React Native。他们对 JavaScript 语言、Cmd + R 或者 Live Reloading 重新加载的工作流、函数式响应式编程和样式表都已经很熟悉了。</p><p>尽管使用 JavaScript 还可能存在很多问题，但这种熟悉的方式提供的生产力让 React Native 成为许多跨平台 app 选择。</p><h2 id="Elm-Native"><a href="#Elm-Native" class="headerlink" title="Elm Native"></a>Elm Native</h2><p>我们喜欢这个工作流，也喜欢这些概念，还熟悉这些语言。但是相比起 Swift 和 Kotlin 这些原生的编译型语言来说，则少了一些安全性和重构的便利性。</p><p>我们如何才能有一个高效的工作流，而不会遇到 JavaScript 错误，比如 undefined is not a function？如果使用 <a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a> 语言可以让我们更自信地说代码是正确的吗？</p><p>幸运的是 Purple Train 是个很简单的 app，这让它能够很好地成为试验新技术的测试平台，请持续关注我们是如何使用 <a href="https://github.com/ohanhi/elm-native-ui" target="_blank" rel="noopener">elm-native-ui</a> 将 Purple Train 迁移到 <a href="http://elm-lang.org/" target="_blank" rel="noopener">Elm</a> 的！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://purpletrainapp.com/" target="_blank" rel="noopener">Purple Train</a> 主页</li><li>阅读 <a href="https://robots.thoughtbot.com/rapid-cross-platform-mobile-development-with-react-native" target="_blank" rel="noopener">Rapid cross-platform mobile development with React Native</a></li><li>收听 <a href="http://bikeshed.fm/86" target="_blank" rel="noopener">Bikeshed Podcast episode about Purple Train</a><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      关于 Purple Train 的说明
    
    </summary>
    
      <category term="Thoughtbot" scheme="https://swift.gg/categories/Thoughtbot/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #76</title>
    <link href="https://swift.gg/2017/07/26/swift-weekly-issue-76/"/>
    <id>https://swift.gg/2017/07/26/swift-weekly-issue-76/</id>
    <published>2017-07-26T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-76/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-29<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p><em>本期作者：<a href="https://twitter.com/garricn" target="_blank" rel="noopener">Garric Nahapetian</a></em></p><p>Swift 的 <a href="https://github.com/apple/swift" target="_blank" rel="noopener">git 仓库</a>这周特别忙，这里有一些 GitHub 的数据：</p><blockquote><p>除了 Merge 之外，总共有 39 个作者 push 了 156 个 commit 到主分支，所有分支算起来有 284 个 commit。在主分支，401 个文件被修改，增 12589 删 9215 …</p></blockquote><p>在 WWDC 结束不久就完成了这么多的事情实属不易，在 Swift 4 立项之后核心团队和别的贡献者完成了惊人的进展。</p><a id="more"></a><p>iOS 11 beat 2，tvOS 11 beta 2 和 Swift Playgrounds 2 beta 2 都开放下载了，点击<a href="https://developer.apple.com/download/" target="_blank" rel="noopener">此处下载</a>，遇到 bug 记得要反馈哦！</p><blockquote><p><strong>赞助链接</strong></p><p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="noopener">提升你的技能 — 成就你的职业生涯</a></p><p>专家带你入门到精通只需一周时间。</p><p><a href="http://www2.bignerdranch.com/l/299472/2017-06-21/8rxl/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_76" target="_blank" rel="noopener">bignerdranch.com</a></p></blockquote><h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在<a href="https://spec.fm/podcasts/swift-unwrapped/70319" target="_blank" rel="noopener">第 17 集：Swift 里的测试</a>，Jesse 和 JP 讨论了如何使用 Swift 和相应的工具进行测试，保证每一个上线版本都井然有序。</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Greg Heo <a href="https://swiftunboxed.com/stdlib/json-encoder-encodable/" target="_blank" rel="noopener">写了一篇文章</a>讲述 Swift 里 <code>Encoder</code> 和 <code>Encodable</code> 的原理，这个新功能会影响到很多开源的软件，了解它的原理更有助于你理解它们相关的 PR。</p><p>Matt Godbolt 的<em>探索编译器</em>现已<a href="https://twitter.com/Catfish_Man/status/877991651548975104" target="_blank" rel="noopener">支持 Swift</a>。（译者注：这是一个学习编译原理的网站，输入代码，就可以看到编译后在对应平台上的汇编码）</p><p>David Owens 放出了一个 <a href="https://owensd.io/2017/06/02/apous-early-preview/" target="_blank" rel="noopener">VSCode 的插件</a>，让 VSCode 也能支持 Swift。</p><p>Swift 支援团队<a href="https://twitter.com/swift_evolution/status/878322333471068160" target="_blank" rel="noopener">开源</a>了 Swift-Evolution 的 App — <a href="https://itunes.apple.com/us/app/evolution-app/id1210898168?mt=8" target="_blank" rel="noopener">Evo</a>。</p><p>Steven Hepting <a href="https://twitter.com/stevenhepting/status/878339681485635585" target="_blank" rel="noopener">讲述</a>了 Swift 的 <code>sort()</code> 方法是怎么优化的，这里可以找到相应的<a href="https://github.com/apple/swift/blob/02e2bd5380af69948d2324b936bfc61e1454d8ea/stdlib/public/core/Sort.swift.gyb#L232-L301" target="_blank" rel="noopener">源码</a>。</p><p><a href="https://www.meetup.com/Learn-Swift-Queens-Meetup/" target="_blank" rel="noopener">Learn Swift 皇后区</a> &amp; <a href="https://www.meetup.com/Learn-Swift-Portland/" target="_blank" rel="noopener">Learn Swift 波兰</a>, 都落下了帷幕。 这是11期  <a href="https://wordpress.com/post/swiftcoders.org/178" target="_blank" rel="noopener">Learn Swift {城市}</a> 系列的合集！下次会是在哪座城市呢？</p><p><a href="https://github.com/br1sk/brisk" target="_blank" rel="noopener">Brisk，一个反馈 bug 的 macOS app</a> 上线了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.0" target="_blank" rel="noopener">1.0 版本</a> ，并且快速迭代发布了 <a href="https://github.com/br1sk/brisk/releases/tag/1.0.1" target="_blank" rel="noopener">1.0.1 版本</a>，记得要帮忙反馈 bug 哦！</p><p>元组门又有了更多的<a href="https://twitter.com/s1ddok/status/879406585939984386" target="_blank" rel="noopener">进展</a>，这对我来说很有趣，因为<a href="https://github.com/garricn/GGNObservable/blob/master/GGNObservable/Classes/Observable.swift#L53" target="_blank" rel="noopener">我个人也使用过类似的方式</a>。就像 <a href="https://twitter.com/slava_pestov/status/879446070190800896" target="_blank" rel="noopener">Slava 指出</a>的那样，这件事情始终还有<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160307/012299.html" target="_blank" rel="noopener">优化的空间</a>。（译者注：元组门就是闭包里的元组不再自动展开的事情，<a href="http://swift.gg/2017/07/16/swift_weekly_issue_74/">前两周</a>的<a href="http://swift.gg/2017/07/24/swift-weekly-issue-75/">周报</a>都有提到，详情请看 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md" target="_blank" rel="noopener">SE-0029</a>，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md" target="_blank" rel="noopener">SE-0066</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="noopener">SE-0110</a>）。</p><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Ben Cohen 发起一个新的<a href="https://github.com/apple/swift-evolution/pull/728" target="_blank" rel="noopener">合并请求</a>，让 <code>Substring</code> 可以添加到 <code>Hashable</code> 容器里（详情请看下面的邮件列表讨论）。</p><p>Itai Ferber <a href="https://github.com/apple/swift/pull/10538" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5277" target="_blank" rel="noopener">SR-5277</a>，让 class 可以与父类共用一个 Encoder/Decoder。更多详情请看这里的<a href="https://twitter.com/garricn/status/878426105585127425" target="_blank" rel="noopener">讨论进程</a>。</p><p>Philippe Hausler <a href="https://github.com/apple/swift/pull/10584" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <a href="https://bugs.swift.org/browse/SR-5292" target="_blank" rel="noopener">SR-5292</a>。修复了 Foundation 里使用 slice 嵌套 slice 时产生的 bug。</p><p>Joe Groff  <a href="https://github.com/apple/swift/pull/10556" target="_blank" rel="noopener">通过了一个合并请求</a>，让 KeyPath 支持可选链（Optional Chainning）和强制解包（Force Unwrapping）。</p><p>Doug Gregor <a href="https://github.com/apple/swift/pull/10565" target="_blank" rel="noopener">通过了一个合并请求</a> ，优化了基本类型，类型别名和递归的处理逻辑，并且修复了 <a href="https://bugs.swift.org/browse/SR-4295" target="_blank" rel="noopener">SR-4295</a>，<a href="https://bugs.swift.org/browse/SR-4757" target="_blank" rel="noopener">SR-4757</a>，<a href="https://bugs.swift.org/browse/SR-4786" target="_blank" rel="noopener">SR-4786</a>，<a href="https://bugs.swift.org/browse/SR-5014" target="_blank" rel="noopener">SR-5014</a> 和 <a href="https://bugs.swift.org/browse/SR-4737" target="_blank" rel="noopener">SR-4737</a>。</p><p>Dave Abrahams <a href="https://github.com/apple/swift/pull/9806" target="_blank" rel="noopener">发起一个合并请求</a>，实现了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">SE-0180</a> 字符串索引越界（后面有详细介绍）。</p><p>在命令行里运行 <code>man swift</code> 时展示的手册<a href="https://github.com/apple/swift/pull/10241" target="_blank" rel="noopener">已获得更新</a>。</p><p>Maxim Moiseev <a href="https://github.com/apple/swift/pull/9466" target="_blank" rel="noopener">通过了一个合并请求</a>，修复了 <code>[String]</code> 使用 <code>flatMap</code> 时的向后兼容性，有兴趣了解的话可以查看这里的 <a href="https://twitter.com/codafi_/status/878330155642396673" target="_blank" rel="noopener">Swift 迷思- by Robert Widmann</a>。</p><p>David Farler <a href="https://github.com/apple/swift-clang/pull/95" target="_blank" rel="noopener">通过了一个合并请求</a>，内容主要是 Xcode 9 里编译时索引功能（index-while-building）在这段时间里的改进。</p><p>如果你想知道某个修复了 <code>rdar://</code> 的 PR 的细节，<a href="https://twitter.com/garricn/status/879551154316689408" target="_blank" rel="noopener">放心大胆地问就可以了</a>。</p><h2 id="审核中的提案"><a href="#审核中的提案" class="headerlink" title="审核中的提案"></a>审核中的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">SE-0180</a>: String Index Overhaul 在一些讨论之后重新退回<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037653.html" target="_blank" rel="noopener">审核阶段</a>。</p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Erica Sadun <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037730.html" target="_blank" rel="noopener">写了一篇文章</a>关于 <code>!!</code> 这个她称为“解包或崩溃”的操作符。你可以在<a href="https://gist.github.com/erica/423e4b1c63b95c4c90338cdff4939a9b" target="_blank" rel="noopener">这个 Gist</a> 里找到相应的草稿。</p><blockquote><p>使用一个操作符，在解包失败时提供反馈信息，已经成为 Swift 开发者社区里普遍会实现的一个东西了，你对于把这个广泛使用的操作符加入到标准库有什么想法？</p><p><em>译者注：使用了 <code>!!</code> 的代码会类似于这样 <code>let _ = optionalObject !! &quot;空的对象&quot;</code>，能够在强制解包失败的时候提供 debug 信息，思路很棒，建议大家看一下。</em></p></blockquote><p>Ben Cohen <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037776.html" target="_blank" rel="noopener">发了一篇文章</a>，内容主要是关于 <code>Substring</code> 性能的讨论。</p><blockquote><p>作为 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0163-string-revision-1.md" target="_blank" rel="noopener">SE-0163</a> 的要点之一，<code>Substring</code> 显式转换到 <code>String</code> 的问题都推迟到第一版实现之后讨论。直到现在，收到的反馈也都没有让我们觉得这样的显式转换很有必要 — 从 3.2 迁移到 4.0 的时候也不怎么需要用到   <code>Substring</code> 到 <code>String</code>的转换。即便不在开发目标里，只要是这方面的版本迁移问题，收到您的反馈我们都会很感谢。</p><p>[…]</p></blockquote><p>Itai Ferber <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037672.html" target="_blank" rel="noopener">在 Swift-Evolution 发了一条信息</a> ，征求 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0166-swift-archival-serialization.md" target="_blank" rel="noopener">SE-0166</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0167-swift-encoders.md" target="_blank" rel="noopener">SE-0167</a> 的反馈，希望社区了解到之前的很多建议已经被采纳并实现，继续提供建议和意见。</p><p>Robert Bennett 提了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037676.html" target="_blank" rel="noopener">有趣的建议</a>，希望 protocol 里可以声明 <code>let</code>。但我并不认为他提的算是一个问题。</p><blockquote><p>我在处理协议的时候遇上了一个恼人的问题。在一个 <code>class</code> 或者 <code>struct</code> 里使用 <code>let</code> 去修饰一个属性并且在 <code>init</code> 方法里初始化是很常见的情况，但却没办法在一个 protocol extension 里实现一个这样的 <code>init</code> 方法。</p><p>[…]</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>“索取”<a href="https://twitter.com/harlanhaskins/status/878499165663240192" target="_blank" rel="noopener">有时候</a>比“给予”感觉更好</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #75</title>
    <link href="https://swift.gg/2017/07/24/swift-weekly-issue-75/"/>
    <id>https://swift.gg/2017/07/24/swift-weekly-issue-75/</id>
    <published>2017-07-24T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-75/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-22<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p><em>本期作者: <a href="https://twitter.com/gregheo" target="_blank" rel="noopener">Greg Heo</a></em></p><p>我不知道你怎么样，但我还沉浸在 WWDC 的余兴里没恢复过来。</p><p>回到实际生活中，苹果发布了 iOS 和 Xcode 的第二个 beta 版。查看<a href="https://developer.apple.com/" target="_blank" rel="noopener">开发者网站</a>，Xcode 9 Beta 2 的更新说明特别提到了 Swift 4 的更新和修复。</p><a id="more"></a><blockquote><p><strong>赞助</strong>  </p><p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="noopener">Advanced Swift Workshops</a>  </p><p>磨炼你的 Swift 技能，在 workshop 里学习一些更深入的主题。诸如 Mike Ash 这样世界知名的开发者，Swift 的专家齐聚一堂，他们将会带领你探索协议，泛型，反射和 C 语言的桥接。7 月 13 日华盛顿场，以及 7 月 24 日纽约场。  </p><p><a href="https://www.eventbrite.com/o/plausible-labs-12068803363/?utm_campaign=Swift_Weekly_Brief&amp;utm_medium=email_web&amp;utm_source=Swift_Weekly_Brief_75" target="_blank" rel="noopener">eventbrite.com</a>  </p></blockquote><h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><p>写测试是一种探索标准库和语言特性的好方式，也能避免给项目留坑。</p><ul><li><a href="https://bugs.swift.org/browse/SR-4824" target="_blank" rel="noopener">SR-4824</a>：编译期添加集合类型约束的检查</li><li><a href="https://bugs.swift.org/browse/SR-5040" target="_blank" rel="noopener">SR-5040</a>：将 “Exclude” 相关的功能性检查改为单元测试</li></ul><p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="noopener">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="noopener">tweet</a> 提交任务。</p><h2 id="Swift-Unwrapped"><a href="#Swift-Unwrapped" class="headerlink" title="Swift Unwrapped"></a>Swift Unwrapped</h2><p>在 <a href="https://spec.fm/podcasts/swift-unwrapped/72297" target="_blank" rel="noopener">第 16 集：Swift 的错误处理 — 发展历史</a> 里，主持人提到了 <code>rethrows</code> 和 “类型” 很多次，缅怀 Objective-C，畅谈 Swift 错误处理机制的发展史。</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Swift 团队的巨星 <a href="https://twitter.com/jckarter/status/875401073447419904" target="_blank" rel="noopener">Joe Groff</a> 要暂时离开 Twitter，Joe 在 Twitter 上一直对社区积极响应，我们希望他早日回归。</p><p>聊到 Joe，<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE" target="_blank" rel="noopener">他的前任</a> <a href="https://twitter.com/clattner_llvm/status/877341760812232704" target="_blank" rel="noopener">Chris Lattner</a> （你们应该都认识）要重新找工作，虽然他说自己有 <a href="https://twitter.com/clattner_llvm/status/877353276676612102" target="_blank" rel="noopener">七年 Swift 开发经验</a>，但我估计大部分公司还是想找一个有十年经验的 <code>¯\_(ツ)_/¯</code></p><p>Xcode 9 和 Swift 4 现在还在测试阶段，现在是一个回顾所有提案的好机会，看一看 <a href="https://twitter.com/ecerney" target="_blank" rel="noopener">Eric Cerney</a> 总结出来的 <a href="https://www.raywenderlich.com/163857/whats-new-swift-4" target="_blank" rel="noopener">What’s New in Swift 4?</a>。</p><p><a href="https://twitter.com/aciidb0mb3r/status/877653585844031493" target="_blank" rel="noopener">Ankit Aggarwal</a> 在 Swift 的博客里写了一篇 <a href="https://swift.org/blog/swift-package-manager-manifest-api-redesign/" target="_blank" rel="noopener">重新设计 Swift Package Manager 的 API</a>，讲述新的 API 设计。Swift 的 package 描述是使用 Swift 写的，新的 API / 格式现在已经更新到了最新的语言设计规范。</p><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Philippe Hausler 提了一些关于 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0170-nsnumber_bridge.md" target="_blank" rel="noopener">SE-0170: NSNumber 与数字类型的桥接</a> 的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037499.html" target="_blank" rel="noopener">反馈</a>，主要是与 Float 和 Double 有关。如果你之前被浮点数的精度问题困扰过的话，可以查看<a href="https://github.com/apple/swift/commit/c358afe6555e5e32633e879f96a3664dc7a5f3dc" target="_blank" rel="noopener">“减少Double 和 Float 桥接的约束条件”的 commit</a>.</p><p>Swift 迁移工具已经 merge 到仓库里了！迁移工具的核心就是把一个文件作为输入，然后输出一份文件，包含了所有修改建议，具体细节请查看 <a href="https://github.com/apple/swift/tree/master/lib/Migrator" target="_blank" rel="noopener">Swift migrator library</a> 文件夹。</p><p>Swift 4 里大家最喜欢的 <code>Encodable</code> 协议，<a href="https://github.com/apple/swift/pull/10321" target="_blank" rel="noopener">添加了对于 non-strong（weak，unowned，unmanaged）属性的支持</a>。</p><p>Swift 问题追踪的第二个 bug 终于终于被修复了！🎉 <a href="https://bugs.swift.org/browse/SR-2" target="_blank" rel="noopener">SR-2</a> 和 <a href="https://bugs.swift.org/browse/SR-4196" target="_blank" rel="noopener">SR-4196</a> 描述了 switch 语法嵌入到 <code>#if</code> / <code>#endif</code> 里的时候不能很好地运行，<a href="https://github.com/apple/swift/pull/9457/commits/5d478bdb3b7638f5df6f0e1f4e574bececae9b80" target="_blank" rel="noopener">最近的一个 commit</a> 终于修复了这个问题.</p><p>Xcode 9 里你可以使用 <a href="https://developer.apple.com/documentation/code_diagnostics/undefined_behavior_sanitizer" target="_blank" rel="noopener">Undefined Behavior Sanitizer</a> 检测所有未定义行为，<a href="https://developer.apple.com/documentation/code_diagnostics/main_thread_checker" target="_blank" rel="noopener">Main Thread Checker</a> 利用现有的 Address Sanitizer 和 Thread Sanitizer 来检测在非主线程刷新 UI 的行为，而。这些新功能都已经 <a href="https://github.com/apple/swift-lldb/pull/211/commits" target="_blank" rel="noopener">merge 到 swift-lldb 里了</a>，如果你感兴趣的话可以去看源代码。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>作为<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015920.html" target="_blank" rel="noopener">这篇去年发布的文章</a>的跟进，<a href="https://github.com/erica" target="_blank" rel="noopener">Erica Sadun</a>，<a href="https://github.com/AliSoftware" target="_blank" rel="noopener">Olivier Halligon</a>，<a href="https://github.com/calebd" target="_blank" rel="noopener">Caleb Davenport</a> 和 <a href="https://github.com/KingOfBrian" target="_blank" rel="noopener">Brian King</a> 提交了一个<a href="https://github.com/erica/swift-evolution/blob/2f2778797ceb9edc0b8acd3b68af5f81f9a95775/proposals/XXXX-role-keywords.md" target="_blank" rel="noopener">关于 protocol extention 函数的 “role keywords” 的提案草稿</a>。主要是讲了重写 protocol extension 里的函数时，需要加上一个关键字显式地声明这是一个 override 行为。</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md" target="_blank" rel="noopener">SE-0110</a> 想要让多个参数 <code>(String, Int)</code>  的函数和单个元组 <code>(String, Int)</code> 参数区分开来。他们看起来是不是一样？就像 Doug Gregor 在邮件列表里提到的，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170619/037616.html" target="_blank" rel="noopener">这个修改会让编译过程变得有点复杂：</a></p><blockquote><p>Swift 4 已经实现了超出 SE-0110 的内容了，特别对于闭包来说，使用体验差了很多。  </p><p>[…]  </p><p>Swift 核心团队觉得这些使用体验的牺牲对于 Swift 4 来说是不可接受的。已经有好几个计划内的解决方案，给闭包提供一个更好的模型，解决用户体验的问题，但完整的设计和实现已经超出了 Swift 4 的开发目标了。所以，我们打算“回滚” SE-0110 在 Swift 4关于函数参数的修改。  </p></blockquote><p>没人可以预知未来，很难了解这些提案对于 Swift 的影响，但这也是为什么我们有 snapshots builds 和 beta 版本。至于说 <a href="http://ericasadun.com/2017/06/20/more-on-se-0110-important-fallout-please-read/" target="_blank" rel="noopener">SE-0110 带来的影响</a> ，我觉得我们应该全部参与进社区里，去鼓励 <a href="https://twitter.com/austinzheng/status/877054901620101120" target="_blank" rel="noopener">Austin Zheng</a>（SE-0110 的作者）继续坚持下去。</p><p>没有新的提案，但照例，更多细节请查看 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift Evolution status page</a>。</p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>还记得 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md" target="_blank" rel="noopener">SE-0104: Protocol-oriented integers</a> 吗？<a href="https://github.com/xwu" target="_blank" rel="noopener">Xiaodi Wu</a> 最近写了一些优化实现方式的<a href="https://gist.github.com/xwu/d68baefaae9e9291d2e65bd12ad51be2" target="_blank" rel="noopener">想法和建议</a>。</p><p>Halen Wooten 开了一个新的<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004829.html" target="_blank" rel="noopener">讨论</a>，讨论作为社区的成员该如何为社区贡献。我知道邮件列表的界面很粗糙，但查看<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/thread.html#4829" target="_blank" rel="noopener">整个讨论</a>总能有一些收获。根据<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004833.html" target="_blank" rel="noopener">文档</a><a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170619/004835.html" target="_blank" rel="noopener">尽量使用增量编译节省时间</a>，我希望类似的这些技巧可以收集起来做成一份入门指南。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>学完 Swift 之后，你会希望做出什么样的语言？<a href="https://twitter.com/slava_pestov/status/875150641269571584" target="_blank" rel="noopener">例如这个</a>，<a href="https://twitter.com/slava_pestov/status/875153089174446080" target="_blank" rel="noopener">可能直接把访问权限去掉</a>? 😱</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Sprite Kit 教程：二维图形动画</title>
    <link href="https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/20/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/</id>
    <published>2017-07-20T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/sprite-movement-actions-sprite-kit-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>Sprite Kit 里，精灵（译者注：精灵的英文单词为 Sprite，计算机图形学，指包含于场景中的二维图像或动画）运动的机制是使用动作（actions）。将某种类型的动作添加到一个节点（node）上，Sprite Kit 自动更新位置直到动作完成。更棒的是，可以将多个动作（actions）组合起来。在本节教程中，我们将学习如何给精灵添加动作。本节教程使用 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，使用 Game 模板创建工程。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/xcode-game-templateformat=1500w1500530564.45" alt=""></p><p>Product Name 使用 <strong>SpriteKitActionsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/spritekit-actions-projectformat=1500w1500530565.94" alt=""></p><p>本节教程需要一个精灵，所以<a href="https://www.ioscreator.com/s/Apple.png" target="_blank" rel="noopener">下载</a>图片，将图片放到 Assets 目录中。</p><p>打开 <strong>GameViewController.swift</strong> 文件，按如下所示修改 <strong>viewDidLoad</strong> 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> scene = <span class="type">GameScene</span>(size: <span class="type">CGSize</span>(width:<span class="number">750</span>, height: <span class="number">1334</span>))</span><br><span class="line">    scene.scaleMode = .aspectFill</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> skView = <span class="keyword">self</span>.view <span class="keyword">as</span>! <span class="type">SKView</span></span><br><span class="line">    skView.presentScene(scene)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gameScene 场景创建好了。打开 <strong>GameScene</strong> 文件，已经定义好了 GameScene 类，删除所有的代码，然后如下所示添加 <strong>didMove(to:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didMove</span><span class="params">(to view: SKView)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> apple = <span class="type">SKSpriteNode</span>(imageNamed: <span class="string">"Apple.png"</span>)</span><br><span class="line">    apple.position = <span class="type">CGPoint</span>(x: size.width/<span class="number">2</span>, y: size.height/<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">self</span>.addChild(apple)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Apple.png 图片赋给变量 apple，将其居中添加到当前场景。<strong>运行</strong>工程，可以看到苹果已经居中出现在屏幕上了。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/center-spritekit-simulatorformat=750w1500530566.73" alt=""></p><p>为了让该精灵运动，需要创建一个运动动作（move action），让该精灵运行此运动动作。将下列代码添加到 <strong>didMove(to:)</strong> 方法的尾部：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveBottomLeft = <span class="type">SKAction</span>.move(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>,y: <span class="number">100</span>), duration:<span class="number">2.0</span>)</span><br><span class="line">apple.run(moveBottomLeft)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，精灵会从中间移动到左下角，耗时 2 秒。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/bottomleft-spritekit-simulatorformat=750w1500530567.46" alt=""></p><p><strong>moveTo:duration</strong> 方法使用的是绝对位置，想让精灵移动到相对的位置，只需要使用 moveBy 变量（To move the sprite relative of the current position you can use the moveBy variant，这句翻译不确定）。只需改变一下两行代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveRight = <span class="type">SKAction</span>.moveBy(x: <span class="number">50</span>, y:<span class="number">0</span>, duration:<span class="number">1.0</span>)</span><br><span class="line">apple.run(moveRight)</span><br></pre></td></tr></table></figure><p>这会让精灵向右移动 50 points。使用 sequence（连贯） 可以将将动作连起来。删除 run 这行代码，添加下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> moveBottom = <span class="type">SKAction</span>.moveBy(x: <span class="number">0</span>, y:-<span class="number">100</span>, duration:<span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom])</span><br><span class="line">        </span><br><span class="line">apple.run(sequence)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>，可以看到连贯的动作。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/sequence-spritekit-simulatorformat=750w1500530568.15" alt=""></p><p>通过调用 <strong>reversedAction</strong>，有些动作可以做反向处理，也就是说，新动作是之前旧动作的相反方向。删除 sequence 这行代码然后填写下列代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reversedMoveBottom = moveBottom.reversed()</span><br><span class="line"><span class="keyword">let</span> sequence = <span class="type">SKAction</span>.sequence([moveRight, moveBottom, reversedMoveBottom])</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，这时可以看到 moveBottom 动作后面跟着一个相反的动作。还可以让动作重复多次或者无限循环，删除 run 这行代码添加下列代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> endlessAction = <span class="type">SKAction</span>.repeatForever(sequence)</span><br><span class="line">apple.run(endlessAction)</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，这些动作会无限循环。</p><p><img src="/img/articles/sprite-movement-actions-sprite-kit-ios-tutorial-ios10/repeat-forever-spritekit-simulatorformat=750w1500530569.94" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>SpriteKitActionsTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Sprite Kit 教程：二维图形动画
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>TableViewController 的最佳实践</title>
    <link href="https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/"/>
    <id>https://swift.gg/2017/07/19/the-best-table-view-controller-mar-2016-edition/</id>
    <published>2017-07-19T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Dominik Hauser，<a href="http://swiftandpainless.com/the-best-table-view-controller-mar-2016-edition/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-03-28<br>译者：<a href="undefined">Doye</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>在阅读 <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/" target="_blank" rel="noopener">obc.io关于轻量级的viewConroller相关讨论</a>之后，每隔几个月我都会反思怎样做才是TableviewController 的最佳实践，我曾经尝试过几种不同的方法包括把 datasource 和 delefate 放到一个独立的类中或者使用 MVVM 架构来对 Cell 进行定制。</p><p>本篇是在 2016 年我对这个问题的思索，而且我对这个方案十分满意，方案涉及到了泛型，协议，和值类型。<br><a id="more"></a></p><p>最主要的一部分是 TableviewController 的基类，它管理着模型数据存储的数组，还需要注册 Cell 类和实现 tableView 所需要的 datasoure 相关的函数。</p><p>我们的类定义如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我们设计的基类是一个 <strong>UITableViewController</strong> 的子类，形参 *Cell<strong> 是一个遵循 </strong>Configurable<strong> 协议的 </strong>UITableViewCell**，这个协议十分简单：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Cell 将会在 <strong>TableViewController</strong> 中注册然后塞进队列，对于这个 Cell 的 identifier 我们可以有一个私有属性的对应：</p><p>然后我们需要一个数组来存储要在 table View 中要展示的数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    tableView.reloadData()</span><br><span class="line">    <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</span><br><span class="line">                                       atScrollPosition: .<span class="type">Top</span>,</span><br><span class="line">                                       animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论数据什么时候被更新，在列表视图中的 <strong>reloadData()</strong> 方法会被调用，而且整个列表视图将上滑至顶部，下面我们定义初始化方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</span><br></pre></td></tr></table></figure><p>在 <strong>viewDidLoad()</strong> 之中我们对于 TableView 进行设置：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</span><br><span class="line">  tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">  tableView.estimatedRowHeight = <span class="number">60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是对 <strong>UITableViewDataSource</strong> 进行补全：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></span><br><span class="line"><span class="function"><span class="params">                        cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</span><br><span class="line">                                                         forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">  cell.config(withItem: data[indexPath.row])</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个需要注意的部分是 <strong>cell.config(withItem: data[indexPath.row])</strong> 这意味着 cell 将负责其内部各种控件展示的内容的填充。</p><p>这里是完整的基类的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">Cell</span>: <span class="title">UITableViewCell</span> <span class="title">where</span> <span class="title">Cell</span>: <span class="title">Configurable</span>&gt;: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> cellIdentifier = <span class="type">String</span>(<span class="type">Cell</span>)</span><br><span class="line">  <span class="keyword">var</span> data = [<span class="type">T</span>]() &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      tableView.reloadData()</span><br><span class="line">      <span class="keyword">if</span> tableView.numberOfRowsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tableView.scrollToRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: <span class="number">0</span>,inSection: <span class="number">0</span>),</span><br><span class="line">                                         atScrollPosition: .<span class="type">Top</span>,</span><br><span class="line">                                         animated: <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>() &#123; <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>) &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    tableView.registerClass(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: cellIdentifier)</span><br><span class="line">    tableView.rowHeight = <span class="type">UITableViewAutomaticDimension</span></span><br><span class="line">    tableView.estimatedRowHeight = <span class="number">60</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// MARK: - Table view data source</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView,</span></span></span><br><span class="line"><span class="function"><span class="params">                          cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier,</span><br><span class="line">                                                           forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span></span><br><span class="line">    cell.config(withItem: data[indexPath.row])</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用这个基类来定义一个 TableViewController 来实现让用户输入一个字符串对于 Github 的用户来进行匹配查找：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSearchTableViewController</span>&lt;<span class="title">T</span>: <span class="title">protocol</span>&lt;<span class="title">DictCreatable</span>, <span class="title">LabelsPresentable</span>, <span class="title">UserProtocol</span>&gt;&gt;: <span class="title">TableViewController</span>&lt;<span class="title">T</span>, <span class="title">TwoLabelCell</span>&gt;, <span class="title">UISearchBarDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> searchString: <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> searchString = searchString <span class="keyword">where</span> searchString.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      <span class="keyword">let</span> fetch = <span class="type">APIClient</span>&lt;<span class="type">T</span>&gt;().fetchUsers(forSearchString: searchString)</span><br><span class="line">      fetch &#123; (items, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> theItems = items <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.data = theItems.<span class="built_in">map</span> &#123; $<span class="number">0</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    title = <span class="string">"User"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> searchBar = <span class="type">UISearchBar</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: view.frame.size.width, height: <span class="number">40</span>))</span><br><span class="line">    searchBar.placeholder = <span class="string">"Github username"</span></span><br><span class="line">    searchBar.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.tableHeaderView = searchBar</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">    searchBar.resignFirstResponder()</span><br><span class="line">    searchString = searchBar.text</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="type">RepositoriesTableViewController</span>&lt;<span class="type">Repository</span>&gt;()</span><br><span class="line">    next.username = <span class="keyword">self</span>.data[indexPath.row].name</span><br><span class="line">    navigationController?.pushViewController(next, animated: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是一个完整的 TableViewController，大部分的代码对于 searchBar 的展示和逻辑处理，是不是很简洁？</p><p>我们会这样来初始化 <strong>UserSearchTableViewController</strong>：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> viewController = <span class="type">UserSearchTableViewController</span>&lt;<span class="type">User</span>&gt;()</span><br></pre></td></tr></table></figure><p>最后，这里是 <strong>TwoLabelCell</strong> 我自己的实现</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoLabelCell</span>: <span class="title">UITableViewCell</span>, <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nameLabel: <span class="type">UILabel</span></span><br><span class="line">  <span class="keyword">let</span> descriptionLabel: <span class="type">UILabel</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">init</span>(style: <span class="type">UITableViewCellStyle</span>, reuseIdentifier: <span class="type">String</span>?) &#123;</span><br><span class="line">    nameLabel = <span class="type">UILabel</span>()</span><br><span class="line">    nameLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">    </span><br><span class="line">    descriptionLabel = <span class="type">UILabel</span>()</span><br><span class="line">    descriptionLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleSubheadline</span>)</span><br><span class="line">    descriptionLabel.numberOfLines = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>(arrangedSubviews: [nameLabel, descriptionLabel])</span><br><span class="line">    stackView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    stackView.axis = .<span class="type">Vertical</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)</span><br><span class="line">    </span><br><span class="line">    addSubview(stackView)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> views = [<span class="string">"stackView"</span>: stackView]</span><br><span class="line">    <span class="keyword">var</span> layoutConstraints = [<span class="type">NSLayoutConstraint</span>]()</span><br><span class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">    layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:|-[stackView]-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">    <span class="type">NSLayoutConstraint</span>.activateConstraints(layoutConstraints)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">config</span><span class="params">(withItem item: Any)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> item = item <span class="keyword">as</span>? <span class="type">LabelsPresentable</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> texts = item.texts</span><br><span class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">      nameLabel.text = texts[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> texts.<span class="built_in">count</span> &gt; <span class="number">1</span> &amp;&amp; texts[<span class="number">1</span>].characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">      descriptionLabel.text = texts[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://github.com/dasdom/TableViewMarch2016" target="_blank" rel="noopener">Github</a>有源码还有另一个遵循类似架构的 TableViewController 实例</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      TableViewController的最佳实践
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift And Painless" scheme="https://swift.gg/tags/Swift-And-Painless/"/>
    
  </entry>
  
  <entry>
    <title>如何检测摇一摇手势</title>
    <link href="https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/18/detect-shake-gestures-ios-tutorial-ios10/</id>
    <published>2017-07-18T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/detect-shake-gestures-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-18<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>iOS 设备可以检测摇一摇手势，在本节教程中，我们将学习如何检测摇一摇手势，检测到该手势后，更新 label 的文案。本节教程使用的是 Xcode 8.3 和 iOS 10.3。<br><a id="more"></a></p><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500341429.27" alt=""></p><p>Product Name 使用 <strong>IOS10ShakeGestureTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-projectformat=1500w1500341431.78" alt=""></p><p>打开 <strong>Storyboard</strong>，从 Object Library 中拖拽一个 Label 控件放到 View Controller 上，双击 Label 控件将文案修改为 <em>“Shake me”</em>。选中该 Label，点击 Auto Layout 的 Align 按钮。选中 “Horizontally in Container”，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500341433.06" alt=""></p><p>选中 Label，点击 Auto Layout 的 Pin 按钮，选中上边距约束线，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/auto-layout-pin-to-topformat=750w1500341433.89" alt=""></p><p>Storyboard 看起来应如下图所示。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-storyboardformat=1000w1500341434.83" alt=""></p><p>打开 Assistant Editor，确保 <strong>ViewController.swift</strong> 可见。按住 Control 键，将 Label 拖拽到 ViewController 类下，创建下图的 Outlet。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-label-outletformat=750w1500341435.62" alt=""></p><p>打开 ViewController.swift 文件，首先要让 View Controller 回应点击事件，可以通过 ViewController FirstResponder 实现，添加下列方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">becomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，要想检测摇一摇手势，添加 <strong>motionEnded(_:with:)</strong> 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">motionEnded</span><span class="params">(<span class="number">_</span> motion: UIEventSubtype, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> motion == .motionShake &#123;</span><br><span class="line">        shakeLabel.text = <span class="string">"Shaken, not stirred"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果确实是一个 Shake Gesture（摇一摇），那么 Label 的文案就会更新。运行工程，摇一摇测试机。可以点击 iOS 模拟器菜单栏 Hardware 选项下的 Shake Gesture 来摇一摇。</p><p><img src="/img/articles/detect-shake-gestures-ios-tutorial-ios10/shake-gesture-simulatorformat=750w1500341436.36" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10ShakeGestureTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      如何检测摇一摇手势
    
    </summary>
    
      <category term="iOS 开发" scheme="https://swift.gg/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>iOS 教程：属性字符串</title>
    <link href="https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/"/>
    <id>https://swift.gg/2017/07/17/attributed-strings-ios-tutorial-ios10/</id>
    <published>2017-07-17T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/attributed-strings-ios-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-04<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="undefined">way</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><blockquote><p>译者注：本文是之前一篇文章的更新版本，<a href="https://www.ioscreator.com/tutorials/attributed-strings-tutorial-ios8-swift" target="_blank" rel="noopener">旧文链接</a>，旧文使用的 Swift 版本不是 3.0，本文更新了代码，升级到了 Swift 3.0。</p></blockquote><p>属性字符串（Attributed Strings）可以为文本赋予各种各样的属性，还能一次给（部分）文本赋值多个属性。在本节教程中，将学会给 label 文本里的每个单词各设置不一样的样式。本节教程使用的是 Xcode 8 和 iOS 10。<br><a id="more"></a></p><p>打开 Xcode，创建一个 Single View Application。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/single-view-xcode-templateformat=1500w1500254455.03" alt=""></p><p>Product Name 使用 <strong>IOS10AttributedStringsTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-projectformat=1500w1500254455.98" alt=""></p><p>打开 <strong>Storyboard</strong>，从 Object-Library（控件库）中拖拽一个 Label 控件到主界面，点击 Storyboard 右下角 Auto Layout 的 Align 按钮，添加下图所示约束，点击 “Add 1 Constraint”。。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-horizontally-in-containerformat=750w1500254456.86" alt=""></p><p>点击 Auto Layout 的 Pin 按钮，添加如下图所示约束，点击 “Add 1 Constraint”。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/auto-layout-pin--to-topformat=750w1500254457.69" alt=""></p><p>点击 Assistant Editor，确保 <strong>ViewController.swift</strong> 文件可见。按住 Control 键，将 Label 控件拖拽到 ViewController 类下面，创建下列 Outlet 连接。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributes-label-outletformat=750w1500254459.19" alt=""></p><p>打开 <strong>ViewController.swift</strong> 文件，如下所示对 <strong>viewDidLoad</strong> 方法进行修改。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">"Testing Attributed Strings"</span></span><br><span class="line">    <span class="keyword">let</span> attributedString = <span class="type">NSMutableAttributedString</span>(string: string)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> firstAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.yellow, <span class="type">NSUnderlineStyleAttributeName</span>: <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> secondAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.red, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.blue, <span class="type">NSStrikethroughStyleAttributeName</span>: <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> thirdAttributes:[<span class="type">String</span>:<span class="type">Any</span>] = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.green, <span class="type">NSBackgroundColorAttributeName</span>: <span class="type">UIColor</span>.black, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">40</span>)]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    attributedString.addAttributes(firstAttributes, range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">8</span>))</span><br><span class="line">    attributedString.addAttributes(secondAttributes, range: <span class="type">NSRange</span>(location: <span class="number">8</span>, length: <span class="number">11</span>))</span><br><span class="line">    attributedString.addAttributes(thirdAttributes, range: <span class="type">NSRange</span>(location: <span class="number">19</span>, length: <span class="number">7</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    attributedLabel.attributedText = attributedString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个普通的字符串，将会转换成多种属性字符串。</li><li>创建见 3 个字典，存储属性的键和值。</li><li>将属性添加到 <code>attributedString</code> 对象中。</li><li>最后，将属性字符串赋值给 Label。</li></ol><p><strong>运行</strong>程序，属性字符串的实现效果如下。</p><p><img src="/img/articles/attributed-strings-ios-tutorial-ios10/attributed-strings-simulatorformat=750w1500254459.94" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10AttributedStringsTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      iOS 教程：属性字符串
    
    </summary>
    
      <category term="iOS" scheme="https://swift.gg/categories/iOS/"/>
    
      <category term="Swift 入门" scheme="https://swift.gg/categories/iOS/Swift-%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="IOSCREATOR" scheme="https://swift.gg/tags/IOSCREATOR/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #74</title>
    <link href="https://swift.gg/2017/07/16/swift_weekly_issue_74/"/>
    <id>https://swift.gg/2017/07/16/swift_weekly_issue_74/</id>
    <published>2017-07-16T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-74/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-15<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="noopener">shanks</a></p></blockquote><!--此处开始正文--><p>WWDC 已经过去一周了，你有大概了解你的代码要怎么迁移到 Swift 4 吗？我最先接触到的是一堆警告，提示有多余的协议遵守，查证得知<a href="https://bugs.swift.org/browse/SR-5153" target="_blank" rel="noopener">这是个 bug</a>。但说回来，比起去年我花了两个星期迁移到 Swift 3 来说，这次的升级已经好很多了。</p><p>而且，牢记 Swift 3.2 版本实际是在 Swift 3 兼容模式下运行 Swift 4 的编译器（<code>-swift-version 3</code>，通过这届 WWDC，我理解了很多东西）。当你在浏览  <a href="https://bugs.swift.org/" target="_blank" rel="noopener">bugs.swift.org</a>  时记住这一点也会很有帮助。<br><a id="more"></a></p><blockquote><p>想要赞助 Swift Weekly Brief 吗? <a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="noopener">点击此处了解更多</a>  </p></blockquote><h2 id="社区任务"><a href="#社区任务" class="headerlink" title="社区任务"></a>社区任务</h2><ul><li>SR-4866：Stack overflow: 空括号表达式语法分析错误</li><li>SR-4830：编译器的 log 加上颜色区分</li></ul><p>可以通过 <a href="https://github.com/SwiftWeekly/swiftweekly.github.io/compare" target="_blank" rel="noopener">pull request</a> 或者 <a href="https://twitter.com/swiftlybrief" target="_blank" rel="noopener">tweet</a> 提交任务。</p><h2 id="Swift-扩展"><a href="#Swift-扩展" class="headerlink" title="Swift 扩展"></a>Swift 扩展</h2><p>第 15 集： <a href="https://spec.fm/podcasts/swift-unwrapped/70809" target="_blank" rel="noopener">Swift 更新内容， Part 2</a></p><p>JP Simard 和 Jesse Squires 继续讨论 Swift 的更新内容</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>John Sundell 写了篇<a href="https://www.swiftbysundell.com/posts/exploring-the-new-string-api-in-swift-4" target="_blank" rel="noopener">关于 Swift 4 新的字符串 API 的文章</a>，这篇文章包括了很多实用的例子，展示了如何在 Swift 日常开发中使用新的字符串 API。</p><p>Slava Pestov 在 Twitter <a href="https://twitter.com/slava_pestov/status/873751462630760449" target="_blank" rel="noopener">提了一个谜题</a>：<code>print(type{ })</code>会输出什么？为什么？（<a href="https://twitter.com/nicklockwood/status/873796388768841728" target="_blank" rel="noopener">答案在这里</a>）</p><p>Slava 也<a href="https://twitter.com/slava_pestov/status/873744097353256961" target="_blank" rel="noopener">强调了</a> Swift 编译器团队，自从 2014 年的<a href="https://github.com/apple/swift/commit/d8ce0b80cbb7732cb32b245f9fadd47c11a4b163" target="_blank" rel="noopener">这一个 commit</a> 开始已经修复了<strong>超过 5500 个 bug 了</strong>。</p><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Slava Pestove <a href="https://github.com/apple/swift/pull/10195" target="_blank" rel="noopener">修复了一个 Swift 3.1 和 Swift 4 的 bug</a>， 当一个类的父类初始化方法是一个 Objective-C 里定义的类工厂方法时，Swift 可能会报错提示 <code>self.init</code> 会让 self 逃逸，所以不能通过编译。</p><p>Devin Coughlin <a href="https://github.com/apple/swift/pull/10191" target="_blank" rel="noopener">加入了对于 inout 的静态分析</a>，加强 Swift 4 的内存安全特性。</p><p>Nate Cook 给新的 Swift 4 的 stdlib <a href="https://github.com/apple/swift/pull/10229" target="_blank" rel="noopener">补充和修改了一大堆文档内容</a>。</p><p>Dave Abrahams 开了一个新的 PR 以便<a href="https://github.com/apple/swift/pull/10223" target="_blank" rel="noopener">改进 String 的性能</a>。</p><p>Roman Levenstein 减少了标准库的代码体积，大概 5-6% 左右，然后从主分支 <a href="https://github.com/apple/swift/pull/10263" target="_blank" rel="noopener">cherry-pick 了一个 patch</a> 到 Swift 4 分支。</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>这周没有提案的更新！具体的可以到<a href="[Swift Evolution]https://apple.github.io/swift-evolution/">这里</a>查看。</p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>本周的讨论围绕 Swift-Evolution 邮件列表应该扮演什么角色的话题展开，因为邮件列表的责任是展示一些有帮助的讨论内容以及提案的审核结果，鉴于邮件主题是由 Swift 发布周期/阶段引导的，什么时候才应该把一个想法带入严肃的讨论中（也许这个想法跟当前开发阶段的主题毫无联系）很值得讨论。</p><p>Ted Kremenek 这么<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170612/037339.html" target="_blank" rel="noopener">写到</a>：</p><blockquote><p>各位：这是一个很好的讨论，很感谢大家对于这件事情的思考。这其实是 Ben Cohen 和我私下聊完之后，我们打算带着核心团队一起讨论这件事。  </p><p>[…]  </p><p>根据 Xiaodi 的观察，evolution 的列表对于推进当前开发目标内的提案的作用是最大的。有很多不同的主题大家想讨论，而且很明显所有人都有点焦虑，想要都参与但人的精力是有限的，很难每一个主题都深入地参与进去。也许把这些移到一个讨论版（我们一直想做，但一直没有精力做的一个东西），提供一个非正式的讨论社区，就像 Xiaodi 提到的 Swift.org 论坛那样的东西，但要把开发目标内外主题明确分开，让大家可以去讨论他们感兴趣的主题。  </p><p>[…]  </p></blockquote><p>如果你对于 Swift Evolution 的发展感兴趣的话，那可以考虑深入阅读，看看这个过程是如何围绕着“开发目标内”呈现有建设性的讨论，以及该如何处理那些不在“当前开发目标内”的想法。</p><p>Chris Lattner 在回顾 <a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="noopener">SE-0110</a> 的一个<a href="https://lists.swift.org/pipermail/swift-evolution//Week-of-Mon-20170612/037514.html" target="_blank" rel="noopener">长期讨论</a>里做了回应：</p><blockquote><p>核心团队今天讨论了这件事情，大家一致认为需要为了重新获得语法的便捷性而做出改变。 讨论之后大家更倾向于（至少）保留闭包里使用括号展开元组的形式，但这件事情还需要更多的讨论。  </p></blockquote><blockquote><p>说一个题外话，给元组里面的元素命名的形式以后某个时间点应该会被取消掉。不仔细看的话，你能分清下面声明了哪个变量吗？：  </p><p><code>let (a : Int, b : Float) = foo()</code>  </p><p>?  </p></blockquote><p>我们在这里回顾一下<a href="https://swiftweekly.github.io/issue-72/" target="_blank" rel="noopener">第 72 期的周报</a>。在 Swift 4 里，n 个元素的元组已经不会在闭包里拓展为 n 个参数了（元组展平行为）。这意味着闭包将会接收一个元组类型的参数，而你需要手动去把它们展开。这很明显就不符合直觉，开发体验也很差。很高兴看到核心团队重新考虑这个决定！谁说 Swift-Evolution 不好的？😉</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>有关 Swift 2 的<a href="https://twitter.com/jckarter/status/874397984712163331" target="_blank" rel="noopener">一些感想</a>🍺。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Swift 周报
    
    </summary>
    
      <category term="Swift 进阶" scheme="https://swift.gg/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Jesse Squires" scheme="https://swift.gg/tags/Jesse-Squires/"/>
    
  </entry>
  
  <entry>
    <title>Swift 3.0 下 Notifications 与 userInfo 的使用</title>
    <link href="https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/"/>
    <id>https://swift.gg/2017/06/13/notifications-and-userinfo-with-swift-3-0/</id>
    <published>2017-06-13T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Joe，<a href="http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/" target="_blank" rel="noopener">原文链接</a>，原文日期：2016-09-17<br>译者：<a href="undefined">Tony Han</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 <a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="noopener">Great Renaming</a>。<code>NSThread</code> 被简写作 <code>Thread</code>，<code>NSData</code> 被简写作 <code>Data</code>，就是这个意思。</p><a id="more"></a><p>这意味着，需要更新通过 <code>userInfo</code> 使用 <code>NSNotificationCenter</code>，哦不，<code>NotificationCenter</code> 的用法。这是 Swift 2 和 Swift 3 之间的巨大差别。</p><p>现在获取默认的 <code>NotificationCenter</code> 的方法已经变成 <code>let nc = NotificationCenter.default</code>。另外，当接收到通知时，使用选择器的模型已经改变为指定要执行的代码块或函数。</p><p>例如，在 Swift 2 中这么写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nc = <span class="type">NSNotificationCenter</span>.defaultCenter()</span><br><span class="line">nc.addObserver(<span class="keyword">self</span>, </span><br><span class="line">               selector: #selector(<span class="type">ViewController</span>.catchNotification),</span><br><span class="line">               name: <span class="string">"MyNotification"</span>, </span><br><span class="line">               object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>而 Swift 3 中要这么写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></span><br><span class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</span><br><span class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>,</span><br><span class="line">               using:catchNotification)</span><br></pre></td></tr></table></figure><p>上面的例子设置了通知中心将 <code>MyNotification</code> 通知传递给具有 <code>(Notification) -&gt; Void</code> 方法签名的 <code>catchNotification</code> 函数。或者也可以使用闭包调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span> <span class="comment">// 注意：default 是属性，不是方法调用</span></span><br><span class="line">nc.addObserver(forName:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</span><br><span class="line">               object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>) &#123;</span><br><span class="line">  notification <span class="keyword">in</span></span><br><span class="line">  <span class="comment">// 处理通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>下面看看如何发送通知。Swift 2.0 中的 <code>postNotificationName</code> 方法在 Swift 3.0 中已经被替换为 <code>post</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">nc.post(name:<span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>),</span><br><span class="line">        object: <span class="literal">nil</span>,</span><br><span class="line">        userInfo: [<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</span><br></pre></td></tr></table></figure><p><code>userInfo</code> 使用 <code>[AnyHashable：Any]?</code> 作为参数，这在 Swift 中被称作字典字面量。注意，<code>userInfo</code> 的值不需要统一类型（即 <code>Any</code> 所占位置）；这里发送了一个 <code>String</code> 类型和一个 <code>Date</code> 类型。</p><h4 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h4><p><code>guard</code> 语法用来从 <code>userInfo</code> 中解包并验证期望数据，这是一个很不错的方式。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</span><br><span class="line">        <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</span><br><span class="line">                                message:<span class="string">"<span class="subst">\(message)</span> received at <span class="subst">\(date)</span>"</span>,</span><br><span class="line">                                preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">  alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">  <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要验证 <code>guard</code> 的作用，可以使用 <code>String</code> 类型或其他的对象类型代替 <code>Date()</code> 来调用 <code>post</code> 方法。可以在控制台的输出中看到 <code>No userInfo found in notification</code>。</p><h4 id="实例源码"><a href="#实例源码" class="headerlink" title="实例源码"></a>实例源码</h4><p>可以在一个简单的 iOS 项目中尝试使用上面的代码。创建 <strong>Single View Application</strong> 项目，并且使用以下内容替换 <code>ViewController.swift</code> 中的内容：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> myNotification = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue:<span class="string">"MyNotification"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    nc.addObserver(forName:myNotification, object:<span class="literal">nil</span>, queue:<span class="literal">nil</span>, using:catchNotification)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">    <span class="keyword">let</span> nc = <span class="type">NotificationCenter</span>.<span class="keyword">default</span></span><br><span class="line">    nc.post(name:myNotification,</span><br><span class="line">            object: <span class="literal">nil</span>,</span><br><span class="line">            userInfo:[<span class="string">"message"</span>:<span class="string">"Hello there!"</span>, <span class="string">"date"</span>:<span class="type">Date</span>()])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">catchNotification</span><span class="params">(notification:Notification)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Catch notification"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> userInfo = notification.userInfo,</span><br><span class="line">          <span class="keyword">let</span> message  = userInfo[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> date     = userInfo[<span class="string">"date"</span>]    <span class="keyword">as</span>? <span class="type">Date</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"No userInfo found in notification"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> alert = <span class="type">UIAlertController</span>(title: <span class="string">"Notification!"</span>,</span><br><span class="line">                                  message:<span class="string">"<span class="subst">\(message)</span> received at <span class="subst">\(date)</span>"</span>,</span><br><span class="line">                                  preferredStyle: <span class="type">UIAlertControllerStyle</span>.alert)</span><br><span class="line">    alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="keyword">default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">    <span class="keyword">self</span>.present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><code>Notification</code> 的“名字”不再是字符串类型，而是 <code>Notification.Name</code> 类型，因此在声明通知的时候使用 <code>let myNotification = Notification.Name(rawValue:&quot;MyNotification&quot;)</code>。这样可以允许我们在任何需要使用 <code>Notification.Name</code> 的地方来使用 <code>myNotification</code>，比如，<code>NotificationCenter.addObserver</code> 和 <code>NotificationCenter.post</code> 方法。</li><li>推荐使用分开的 <code>catchNotification</code> 方法而不是纠缠在一起的代码块。</li></ul><p>就是这样，简洁而有效！</p><h4 id="评论内容"><a href="#评论内容" class="headerlink" title="评论内容"></a>评论内容</h4><p>声明并使用通知的改进：</p><p>1) 首先声明通知名称：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">MyNotification</span> = <span class="type">Notification</span>.<span class="type">Name</span>(<span class="string">"Notification.MyApp.MyNotification"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 使用通知名称发送通知：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><p>3) 监听通知：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(forName: <span class="type">Notification</span>.<span class="type">MyApp</span>.<span class="type">MyNotification</span>, object: <span class="literal">nil</span>, queue: <span class="type">OperationQueue</span>.main) &#123;</span><br><span class="line">      pNotification <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Joe，&lt;a href=&quot;http://dev.iachieved.it/iachievedit/notifications-and-userinfo-with-swift-3-0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2016-09-17&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Tony Han&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 3.0 版本给 Swift 语言带来了相当多的改变，包括去掉 Foundation 框架中 NS 前缀的 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/403/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Great Renaming&lt;/a&gt;。&lt;code&gt;NSThread&lt;/code&gt; 被简写作 &lt;code&gt;Thread&lt;/code&gt;，&lt;code&gt;NSData&lt;/code&gt; 被简写作 &lt;code&gt;Data&lt;/code&gt;，就是这个意思。&lt;/p&gt;
    
    </summary>
    
      <category term="iAchieved.it" scheme="https://swift.gg/categories/iAchieved-it/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 周报 #73</title>
    <link href="https://swift.gg/2017/06/10/issue-73/"/>
    <id>https://swift.gg/2017/06/10/issue-73/</id>
    <published>2017-06-10T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Jesse Squires，<a href="https://swiftweekly.github.io/issue-73/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-06-09<br>译者：<a href="https://kemchenj.github.io" target="_blank" rel="noopener">四娘</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这周的事情很多！今天是 <a href="https://developer.apple.com/videos/wwdc2017/" target="_blank" rel="noopener">WWDC 2017</a> 的最后一天，Swift 4 随着 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode 9</a>，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个<a href="https://twitter.com/ericasadun/status/871819962888802304" target="_blank" rel="noopener">社区</a>的<a href="https://twitter.com/SmileyKeith/status/871852588844556288" target="_blank" rel="noopener">反响</a><a href="https://twitter.com/fpillet/status/871987276187828224" target="_blank" rel="noopener">都</a><a href="https://twitter.com/chriseidhof/status/873066951739703296" target="_blank" rel="noopener">很</a><a href="https://twitter.com/tonyarnold/status/873017116298846208" target="_blank" rel="noopener">正</a><a href="https://twitter.com/ayanonagon/status/871850052498489344" target="_blank" rel="noopener">面</a>。恭喜 Apple 的 Xcode, Swift 和开发工具组！</p><a id="more"></a><blockquote><p>想要赞助 Swift Weekly Brief 吗？<a href="https://swiftweekly.github.io/sponsorship/" target="_blank" rel="noopener">点击此处了解更多</a>  </p></blockquote><h2 id="Swift-解包"><a href="#Swift-解包" class="headerlink" title="Swift 解包"></a>Swift 解包</h2><p>第 14 集：<a href="https://spec.fm/podcasts/swift-unwrapped/70808" target="_blank" rel="noopener">Swift 更新内容，Part 1</a></p><p>我们讨论了 Swift 4 里的一些新功能和改进。</p><h2 id="资讯及社区"><a href="#资讯及社区" class="headerlink" title="资讯及社区"></a>资讯及社区</h2><p>Apple <a href="https://www.apple.com/newsroom/2017/06/swift-playgrounds-expands-coding-education-to-robots-drones-and-musical-instruments/" target="_blank" rel="noopener">宣布</a> Swift Playgrounds 已经支持对玩具机器人和无人机的编程了。他们正与多家公司合作，包括 Lego, Sphero 等一众公司。 这件事情很棒很好玩，你可以在这里查看<a href="https://www.youtube.com/watch?v=v7926MzvXOQ" target="_blank" rel="noopener">相关视频</a>。</p><p>Erica Sadun 的新书 <a href="http://ericasadun.com/2017/06/01/swift-style-wwdc-sale/" target="_blank" rel="noopener">Swift Style</a> 这周正式开始销售。</p><p>objc.io 已经放出了他们的新书，<a href="https://www.objc.io/blog/2017/06/02/optimizing-collections/" target="_blank" rel="noopener">Optimizing Collections</a>。作者 <a href="https://twitter.com/lorentey" target="_blank" rel="noopener">Károly Lőrentey</a> 在这本书里介绍了如何使用 Swift 编写高效的自定义集合类型。</p><p><a href="https://developer.apple.com/news/?id=06052017d" target="_blank" rel="noopener">Xcode 9 beta 以及新的 SDK</a> 全都放出来啦！</p><h2 id="WWDC-里关于-Swift-的视频"><a href="#WWDC-里关于-Swift-的视频" class="headerlink" title="WWDC 里关于 Swift 的视频"></a>WWDC 里关于 Swift 的视频</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2017/402/" target="_blank" rel="noopener">What’s new in Swift</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/408/" target="_blank" rel="noopener">What’s new in Swift Playgrounds</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/416/" target="_blank" rel="noopener">Teaching with Swift Playgrounds</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/212/" target="_blank" rel="noopener">What’s new in Foundation</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/407/" target="_blank" rel="noopener">Understanding undefined behavior</a></li></ul><h2 id="提交和合并的请求"><a href="#提交和合并的请求" class="headerlink" title="提交和合并的请求"></a>提交和合并的请求</h2><p>Rober Widmann <a href="https://github.com/apple/swift/pull/10175" target="_blank" rel="noopener">合并了修改</a>，使用了 Xcode 新的未定义行为检测器，来修复了一些未定义的行为。</p><p>Roman Levenstein <a href="https://github.com/apple/swift/pull/10096" target="_blank" rel="noopener">做了一些小调整</a>，让标准库的代码体积减少了 1.5% ！！！</p><p>Swift 服务端 API 工作组发布了一个<a href="https://github.com/swift-server/http" target="_blank" rel="noopener">新的 repo</a>，主要是关于跨平台 HTTP API 的开发。</p><p>Ben Cohen 向 <code>swift-4.0 分支</code><a href="https://github.com/apple/swift/pull/10161" target="_blank" rel="noopener">发起了一个合并的请求</a>，用于提高 substring 比较的性能。Nate Cook <a href="https://github.com/apple/swift/pull/10156" target="_blank" rel="noopener">也发起了一个提高字典效率的合并请求</a>，现在已经有<a href="https://github.com/apple/swift/pulls?utf8=✓&amp;q=is%3Apr%20%5B4.0%5D%20in%3Atitle" target="_blank" rel="noopener">好几个 Swift 4 的合并请求</a> 了，希望那些已经请求完成的合并请求可以尽快通过。我们应该可以在接下来的 beta 版里看到这些改进。</p><p>Slava Pestov <a href="https://github.com/apple/swift/pull/10162" target="_blank" rel="noopener">修复</a>了几个 Bug。👏</p><h2 id="正在-review-的提案"><a href="#正在-review-的提案" class="headerlink" title="正在 review 的提案"></a>正在 review 的提案</h2><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">SE-0180</a>：字符串索引类型统一，Dave Abrahams，<a href="https://lists.swift.org/pipermail/swift-evolution-announce/2017-June/000384.html" target="_blank" rel="noopener">正在 review</a></p><blockquote><p>现在 <code>String</code> 跟它的 <code>CharacterView</code> 共用一个 <code>Index</code> 类型，但 <code>UTF8View</code>，  <code>UTF16View</code> 以及 <code>UnicodeScalarView</code> 就不是了。这个提案重新定义了这几个类型的 <code>Index</code> 类型，让它们跟 <code>String</code> 保持一致。并且暴露一个公开的 <code>encodedOffset</code> 属性和构造器，用于序列化和反序列化 <code>String</code> 和 <code>Substring</code> 的索引值。  </p><p>[…]</p><p>这样的结果就是很多 API 都无法从原本的设计中获益，通常来说，一个 view 的索引如果可以在另一个 view 有对应的索引值的话，这些索引值的转换都应该在内部完成，而不是像现在这样需要写很多不必要的代码。 </p><p>[…]  </p><p>所有 String 的 view 都会使用同一种 Index 类型 (<code>String.Index</code>)，这样索引值就可以在内部进行转换，而不用显式地去完成。  </p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0180-string-index-overhaul.md" target="_blank" rel="noopener">查看原文…</a>  </p></blockquote><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>Ted Kremenek 发布了<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20170605/004751.html" target="_blank" rel="noopener">一个公告</a>，关于即将开源的重构工具，以及其它在 WWDC 公布的事情：</p><blockquote><p>今天下午在 WWDC 上，我们发布了 Xcode 9 里新的重构功能(支持 Swift，C，Objective-C 和 C++)。我们同时宣布将会把这个引擎的核心代码开源出来，包括 Xcode 编译时才会索引的新功能。 </p><p>大概会在接下来的几个星期里, 我们将会分阶段把这些代码发布出来： </p><ul><li><p>关于 Swift 的重构功能，我们还需要做一些收尾工作，例如文档的编写，我们想在发布之前完成。 Argyrios Kyrtzidis 和他的团队负责处理这个计划。  </p></li><li><p>关于 C/C++/Objective-C 的重构功能，我们想和 LLVM 社区一起完成然后并入 LLVM。第一阶段应该会在 swift-clang 的 repo 里完成，但是他们想做的不只是这些。Duncan Exon Smith 和他的团队负责这个计划。  </p></li><li><p>我们也会开源编译器对于编译时索引的支持，包括了 Clang 和 Swift。Argyrios 和他的团队负责推进这件事。关于 Clang 的改变他们应该会在也会在 swift-clang 上完成，然后跟 LLVM 社区讨论如何将他们并入 Clang 里。  </p></li><li><p>最后，我们将会把 Swift 迁移工具剩余的部分开源出来。Argyrios 和他的团队负责推进这件事情，这些修改只会在 Swift 仓库里完成。  </p></li></ul><p>和之前一样，我们还需要完成 Swift 与 Apple 最新的 SDK 的桥接工作。希望可以在下周之前完成，之后我们就会暂时关闭仓库的 commit 权限。相关的细节之后会通过邮件公布。在此之前， Swift.org 的可下载的工具链都可以跟 Xcode 8.3.2 交互。在这之后, 我们可下载的工具链就主要会面向 Xcode 9 beta。这件事情很必要，因为之后最上层的 API 会依赖于最新的 SDK。  </p></blockquote><p>Rick Ballard 发了一个关于 Swift 4 包管理器的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="noopener">公告</a>:</p><blockquote><p>Hello, Swift Pacakage Manager 的社区。  </p><p>我想要汇报一下 Swift 4 里 SwiftPM 的开发进度。我们已经在这个春季实现了一系列的 evolution 提案： </p><ul><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0152-package-manager-tools-version.md" target="_blank" rel="noopener">SE-0152</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0158-package-manager-manifest-api-redesign.md" target="_blank" rel="noopener">SE-0158</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0151-package-manager-swift-language-compatibility-version.md" target="_blank" rel="noopener">SE-0151</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0146-package-manager-product-definitions.md" target="_blank" rel="noopener">SE-0146</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0175-package-manager-revised-dependency-resolution.md" target="_blank" rel="noopener">SE-0175</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0150-package-manager-branch-support.md" target="_blank" rel="noopener">SE-0150</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0162-package-manager-custom-target-layouts.md" target="_blank" rel="noopener">SE-0162</a> […]  </li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0149-package-manager-top-of-tree.md" target="_blank" rel="noopener">SE-0149</a> […]  </li></ul><p>除了这些提案，我们还实现了一些重大的改进： </p><ul><li><p>在 macOS 上，包的交互和包的编译现在都沙盒化了，能够减轻恶意软件带来的损耗。 </p></li><li><p>许多错误信息和诊断都加强了，包括依赖管理时出现的冲突。</p></li><li><p>Xcode 工程文件生成器也改进了，现在允许在重新生成工程文件时让 scheme 引用包里的 target。  </p></li><li><p>并且做了大量的小改进和 bug 修复。  </p></li></ul><p>Xcode 9 在新的编译系统里为 Swift 包管理提供了原生的支持。这个编译系统提供了灵活性和拓展性，让 Xcode 可以支持新的编译模型，例如 Swift 包管理。此外, SwiftPM 为 SwiftPM 的库做了大量的工作，让 Swift 包管理的工具可以轻松嵌入诸如 Xcode 的软件里。</p><p>那 SwiftPM 4 还有什么？首先，我们将会实现 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0179-swift-run-command.md" target="_blank" rel="noopener">SE-0179</a>，支持 <code>swift package run</code> 命令。另外，我们还希望开始放下现在的版本，然后开始计划后面，虽然我们还是在接收建议和 evolution 的提案   </p><p>[…]  </p><p>其它功能我们应该会考虑在下个版本进行支持，例如包资源(例如图片)，许可证和元数据支持，用于处理源代码控制分支的显式支持，以及一个泛用的机制去处理编译工具不支持包管理的情况。最后, 我们确实考虑了之后建立一个中心化的包索引机制，我们也许会在接下来一年为这件事情做一些基础工作。 </p><p><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170605/037002.html" target="_blank" rel="noopener">查看原文…</a>  </p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后 – <a href="https://twitter.com/NeoNacho/status/871143591258734594" target="_blank" rel="noopener">self storage</a></p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Jesse Squires，&lt;a href=&quot;https://swiftweekly.github.io/issue-73/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-06-09&lt;br&gt;译者：&lt;a href=&quot;https://kemchenj.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;四娘&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这周的事情很多！今天是 &lt;a href=&quot;https://developer.apple.com/videos/wwdc2017/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2017&lt;/a&gt; 的最后一天，Swift 4 随着 &lt;a href=&quot;https://developer.apple.com/xcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Xcode 9&lt;/a&gt;，一起放出了开发者公测版。Xcode 和 Swift 都有好几个重大的改进和新的功能 — 这个版本真的很棒。整个&lt;a href=&quot;https://twitter.com/ericasadun/status/871819962888802304&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;社区&lt;/a&gt;的&lt;a href=&quot;https://twitter.com/SmileyKeith/status/871852588844556288&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反响&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fpillet/status/871987276187828224&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;都&lt;/a&gt;&lt;a href=&quot;https://twitter.com/chriseidhof/status/873066951739703296&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;很&lt;/a&gt;&lt;a href=&quot;https://twitter.com/tonyarnold/status/873017116298846208&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正&lt;/a&gt;&lt;a href=&quot;https://twitter.com/ayanonagon/status/871850052498489344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面&lt;/a&gt;。恭喜 Apple 的 Xcode, Swift 和开发工具组！&lt;/p&gt;
    
    </summary>
    
      <category term="Jesse Squires" scheme="https://swift.gg/categories/Jesse-Squires/"/>
    
    
      <category term="Swift 周报" scheme="https://swift.gg/tags/Swift-%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Table View 中开启文本菜单功能</title>
    <link href="https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/"/>
    <id>https://swift.gg/2017/06/09/use-context-menu-with-table-view-tutorial-ios10/</id>
    <published>2017-06-09T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Arthur Knopper，<a href="https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-01-09<br>译者：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><hr><!--此处开始正文--><p>长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。</p><a id="more"></a><h3 id="设置工程"><a href="#设置工程" class="headerlink" title="设置工程"></a>设置工程</h3><p>打开 Xcode，创建一个 Single View Application。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58ff88928419c2b2a27d0754/1493141675229/single-view-xcode-template?format=1500w" alt=""></p><p>点击 Next。Product Name 使用 <strong>IOS10ContextMenuTableViewTutorial</strong>，填写自己的 Organization Name 和 Organization Identifier，Language 一栏选择 Swift，Devices 一栏选择 iPhone。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284518419c2902d0b4038/1483899997903/?format=1500w" alt=""></p><p>打开 <strong>Main.storyboard</strong> 文件，从 Object Library 中拖拽一个 Table View 到主界面，然后选中 Table View，找到 Attribute Inspector，在 Table View 部分，将 Prototype Cells 的值改为1。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728478414fb539f1673cc0/1483900034219/?format=500w" alt=""></p><p>选中 Table View Cell，找到 Attribute Inspector ，在 Table View Cell 区域，将 Indentifier 的值设置为 “cell”。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728493bf629afa514967a5/1483900060894/?format=750w" alt=""></p><p>选中 Table View，点击右下角的 Pin 按钮，点击上方、左、右三条线，选择 Height，设置成固定高度。在 Update Frames 的下拉菜单中选择 Items of New Contraints，接下来点击 “Add 4 Constraints”。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587284b5725e2549f7b0a58c/1483900094417/?format=750w" alt=""></p><p>从 Object Library 中拖拽一个 Text Field 控件，放到 Table View 的下方。按住 Control 键，将其拖拽到 Table View 上，松开 Control 键，选择 “Vertical Spacing” 和 “Center Horizontally”。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587285ead1758edd735361d8/1483900403738/Autolayout-Pinleftandright.png?format=500w" alt=""></p><p>选中 Text Field，点击右下角的 Pin 按钮，选中左、右两条线。如下图添加约束。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/587286031e5b6c9fdaadb7b3/1483900432899/?format=750w" alt=""></p><p>View Controller 需要成为 Table View 的代理（delegate）。选中 TableView，按住 Control 键，将其拖拽到 View Controller 顶部的黄色图标上，点击 dataSource，重复上述步骤，点击 delegate。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728664bebafb08e6a84d26/1483900526787/?format=300w" alt=""></p><p>对 Text Field 控件也重复上述步骤，使 View Controller 成为 Text Field 的代理（delegate）。然后打开 <strong>ViewController.swift</strong> 文件，将类的声明改成如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITextFieldDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>接着添加下列属性：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pasteBoard = <span class="type">UIPasteboard</span>.generalPasteboard()</span><br><span class="line"><span class="keyword">var</span> tableData: [<span class="type">String</span>] = [<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"fish"</span>]</span><br></pre></td></tr></table></figure><p>pasteBoard 属性将用于复制粘贴操作，tableData 存储展示在 Table View Cell 上的数据。接下来，如下所示修改 Table View 的 delegate 方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfSections</span><span class="params">(<span class="keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tableData.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="string">"cell"</span>, <span class="keyword">for</span>: indexPath)</span><br><span class="line">        </span><br><span class="line">    cell.textLabel?.text = tableData[indexPath.row]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table View 现在会展示 tableData 数组中的值，想要开启文本菜单功能，需要实现以下三个 delegate 方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action == #selector(<span class="type">UIResponderStandardEditActions</span>.copy(<span class="number">_</span>:))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, performAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.cellForRow(at: indexPath)</span><br><span class="line">    pasteBoard.string = cell!.textLabel?.text</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tableView:shouldShowMenuForRowAt</strong> 方法必须返回 true，才能长按显示文本菜单。<strong>tableView:canPerformAction:forRowAt</strong> 方法，让文本菜单只显示 copy（复制）一个选项。<strong>tableView:performAction:forRowAt:withSender</strong> 方法将选中的文本复制到 pasteBoard 变量中。</p><p>最后，通过 <strong>textFieldShouldReturn</strong> 方法，在点击 Text Field 后让键盘消失。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(<span class="number">_</span> textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.endEditing(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行</strong>工程，长按一行 Table View Cell，然后选择 copy（复制） 选项，粘贴到 Text Field（文本框）里。</p><p><img src="https://static1.squarespace.com/static/52428a0ae4b0c4a5c2a2cede/t/58728d2c1b631b6a2299ad67/1483902262012/?format=750w" alt=""></p><p>可以从 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="noopener">github</a> 上下载 <strong>IOS10ContextMenuTableViewTutorial</strong> 教程的源代码。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Arthur Knopper，&lt;a href=&quot;https://www.ioscreator.com/tutorials/use-context-menu-with-table-view-tutorial-ios10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-01-09&lt;br&gt;译者：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;长按所选的对象后，弹出文本菜单（Context Menu），允许用户进行剪切、复制、粘贴操作。默认情况下，文本菜单功能在 Table View 中是关闭状态。在本节教程中，将学习如何在 Table View Cell 中开启文本菜单功能，将所选的文本复制到 Text Filed（文本输入框）中。本节教程使用的是 Xcode 8.1 和 iOS 10。&lt;/p&gt;
    
    </summary>
    
      <category term="IOSCREATOR" scheme="https://swift.gg/categories/IOSCREATOR/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>把代码迁移到协调器上</title>
    <link href="https://swift.gg/2017/06/09/migrating-to-coordinators/"/>
    <id>https://swift.gg/2017/06/09/migrating-to-coordinators/</id>
    <published>2017-06-09T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/migrating-to-coordinators/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-4-25<br>译者：<a href="http://weibo.com/277195544" target="_blank" rel="noopener">Cwift</a>；校对：<a href="http://www.jianshu.com/users/7a2d2cc38444/latest_articles" target="_blank" rel="noopener">Crystal Sun</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>这篇文章是 <a href="http://khanlou.com/tag/advanced-coordinators/" target="_blank" rel="noopener">Coordinators（协调器）进阶教程系列</a>的第一篇。如果你没有阅读过<a href="http://khanlou.com/2015/01/the-coordinator/" target="_blank" rel="noopener">原始的帖子</a>及其<a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">后续</a>，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。</p><a id="more"></a><p>常有人问我，如何把一个使用 Storyboard 构建或者是使用纯代码编写 ViewController 构建的应用重构成使用 Coordinators 的应用。只要方法正确，重构可以逐步完成。即使重构未完成，你的应用仍旧可以部署。</p><p>要实现这个目标，最好的做法是从根路径出发，在 Coordinators 中称之为 “AppCoordinator”。AppDelegate 持有该 AppCoordinator，AppCoordinator 调度 App 可以加载的所有 ViewController。</p><p>想要理解为什么从 App 的根路径开始，可以从反面来思考。如果从一些叶子流程开始（比如，一个 <code>CheckoutCoordinator</code>），那么需要保持对该 Coordinator 的强引用，以防它被释放。如果 Coordinator 被释放，它内部的代码就都不能执行了。所以，深入一个 App 中去，如果我们创建一个 Coordinator，必须让某个对象长久地持有它。</p><p>有两种方案可以防止对象被释放。第一种方案是使用静态引用。因为系统里可能只有一个 <code>CheckoutCoordinator</code>，所以很容易将其填充到一个全局变量中。虽然这种方案有效果，但是不是一个理想的选择，因为全局变量阻碍了可测试性和灵活性。第二种方案是让当前展示的 ViewController 持有 Coordinator。这将迫使当前的 ViewController 变得复杂一些，但是可以降低 Coordinator 所管理的所有 ViewController 的复杂性。然而，这种关系本质上是有缺陷的。ViewController 是 Coordinator 的“孩子”，编程时，孩子们不应该不知道他们的父母是谁。类似于一个 <code>UIView</code> 持有了一个 <code>UIViewController</code> 的引用：这种事是不该发生的。</p><p>如果你遇到了必须从子流程开始的情况，你可以使用上述两种方法之一。但是，如果可以选择，我的建议是从根路径开始。</p><p>从根路径开始的另一个好处是认证流程通常更靠近 App 的根路径。身份认证是一个很好的流程，可以抽象成单独的对象，很适合用来验证 App 中的 Coordinator。</p><p>将 App 的 RootViewController 交付给 <code>AppCoordinator</code> 之后，你可以对代码进行 Commit/Pull Request/Code Review。因为其他的 ViewController 仍在正常运转，所以 App 可以在这个未完工的状态下继续工作。基于这点，逐步改造，你可以将更多的 ViewController 交付给 Coordinator。将每个“流程”都交付给 Coordinator 之后，你可以提交代码或者创建一个 pr，不会影响 App 的正常工作。正如最佳重构一样，这些步骤只是移动代码，有时根据需要创建新的 Coordinator。</p><p>一旦所有的场景切换都转移到了 Coordinator 中，你就可以开始下一步的重构了，例如将 iPhone 和 iPad 的 Coordinator 封装到单独的对象（而不是一个切换状态的 Coordinator），让子流程可复用，更好地依赖注入，这些都可以应用到你的新架构中。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/migrating-to-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-4-25&lt;br&gt;译者：&lt;a href=&quot;http://weibo.com/277195544&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cwift&lt;/a&gt;；校对：&lt;a href=&quot;http://www.jianshu.com/users/7a2d2cc38444/latest_articles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crystal Sun&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;这篇文章是 &lt;a href=&quot;http://khanlou.com/tag/advanced-coordinators/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coordinators（协调器）进阶教程系列&lt;/a&gt;的第一篇。如果你没有阅读过&lt;a href=&quot;http://khanlou.com/2015/01/the-coordinator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原始的帖子&lt;/a&gt;及其&lt;a href=&quot;http://khanlou.com/2015/10/coordinators-redux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;后续&lt;/a&gt;，请务必首先查阅这些文章。该系列将涵盖几项进阶的 Coordinator 使用技巧、疑点、常见问题以及其他细碎的内容。让我们开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="KHANLOU" scheme="https://swift.gg/categories/KHANLOU/"/>
    
    
      <category term="iOS 开发" scheme="https://swift.gg/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的安全性</title>
    <link href="https://swift.gg/2017/06/06/safety-in-swift/"/>
    <id>https://swift.gg/2017/06/06/safety-in-swift/</id>
    <published>2017-06-06T00:00:00.000Z</published>
    <updated>2018-04-22T13:49:47.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Soroush Khanlou，<a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="noopener">原文链接</a>，原文日期：2017-04-05<br>译者：<a href="undefined">Doye</a>；校对：<a href="http://chengway.in/" target="_blank" rel="noopener">walkingway</a>；定稿：<a href="https://github.com/chenmingbiao" target="_blank" rel="noopener">CMB</a></p></blockquote><!--此处开始正文--><p>Swift 是一门注重安全性的语言，如<a href="https://Swift.org/" target="_blank" rel="noopener">Swift官网</a>的<a href="https://Swift.org/about/" target="_blank" rel="noopener">关于页面</a>中所言</p><blockquote><p>Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。</p></blockquote><a id="more"></a><p>还有它的说明</p><ul><li><p><strong>安全性</strong>：那些显而易见而又便捷的编程方法应该保证是安全的。未定义的行为会破坏软件的安全性。在软件发布之前就要把开发者的错误扼杀在萌芽之中。强调安全性有时会让你觉得 Swift 语法过于严苛，但是它带来的代码的明晰从长远来看还是利大于弊的。</p></li><li><p><strong>高性能</strong>: Swift旨在替代 C 系语言（C，C ++和Objective-C），因此 Swift 必须在绝大多数任务中与这些语言有着接近的性能指数，而且性能需要具有可预测性。而且这种指数需要是一种普遍的性能指数，而不是昙花一现的仅仅几种任务类型的高性能。具有各种特性的语言有很多，但仍保持着如此高性能却实属罕见。</p></li><li><p><strong>表现力</strong>:  Swift 受益于计算机科学的几十年发展，提供了开发人员期望的现代功能并具有有趣的语法。而且 Swift 并不止步于此，Swift 社群会关注编程语言的发展并取其精华，使得 Swift 一直保持进化，变得更好。</p></li></ul><p>举例来说，类似 <strong>Optional</strong> 这种类型就是 Swift 考虑安全性的一个体现，在其他的编程语言当中，你并不能知道哪个变量可以为空(null)哪个不能，而 <strong>Optional</strong> 携带着改变量可能为空的信息，这就强制开发者去考虑可能为空的情况。对于”可空”（nullable）的类型，如果你用强解包符号（<strong>!</strong>）来处理该类型，有些时候它会直接 crash。Swift 的安全性相当于一条安全带，你可以自行解开它，但是风险也要自己来承担。</p><p>然而在某些情况下，安全性看起来并不足够。比如举例来说，如果我们有一个字典，我们需要通过一些 key 来提取到返回值类型为 optional 的 value</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: [<span class="type">String</span>: <span class="type">String</span>] = <span class="comment">//...</span></span><br><span class="line">type(of: person[<span class="string">"name"</span>]) <span class="comment">// =&gt; Optional&lt;String&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果我们对数组进行类似的操作，我们并不会得到一个 optional:</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users: [<span class="type">User</span>] = <span class="comment">//...</span></span><br><span class="line">type(of: users[<span class="number">0</span>]) <span class="comment">// =&gt; User</span></span><br></pre></td></tr></table></figure><p>原因是数组可能没有元素，如果 <strong>users</strong> 的数组为空的话，这段程序将会直接crash，从这方面来看，好像Swift并没有做到足够安全。</p><p>Swift仍然在开放的演进中，你可能就此问题提些建议到 <a href="http://khanlou.com/2017/04/safety-in-swift/" target="_blank" rel="noopener">Swift evolution邮件组</a><br>不，那也不会有什么改变，在 <strong>Swift evolution</strong> 的 github 库里 <a href="https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md" target="_blank" rel="noopener">”常见驳回”提议页</a> 当中描述了不会接受这项提议：</p><ul><li>Array&lt; T &gt; 的下标获取操作不返回一个 <strong>T</strong> 而是返回一个 <strong>T?</strong> 或者 <strong>T!</strong>，当前的数组的逻辑是<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002446.html" target="_blank" rel="noopener">故意为之</a>，它准确反映了访问越界的数组下标是一个逻辑错误。如果改变目前的逻辑会降低数组的读取到一个无法接受的程度，这项提议<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002425.html" target="_blank" rel="noopener">提出多次</a>并不会被社区采纳。</li></ul><p>这里指出的原因是在这种特殊情况下，性能至关重要。但是如果我们回过头来看上面引用的关于页当中的信息，”安全性”的地位应该是高于”速度”的，难道安全性不应该比速度更为重要么？</p><p>这里存在着一个根本的争议点，在于”安全性”一词的定义。对于”安全性”一个普遍的理解是不 crash，而 Swift 核心成员的定义是”永远不会在无意中访问错误的内存”。</p><p>从这点来看，Swift 的下标操作是”安全的”，它永远都不会去访问在数组自身分配之外的内存，当你想访问数组越界的内存时它会立即 crash，如 Optional 类型避免了当前存在的各种空指针引用的 bug 一样，数组这里的考虑避免了缓冲区溢出的 bug。</p><p>Chris Lattner（Swift 作者）在<a href="https://overcast.fm/+CdTE-_oY/24:37" target="_blank" rel="noopener">这段采访</a>的24.39处有段说明</p><blockquote><p>我们采用的安全性策略是在综合的一种妥协。我们想使Swift成为一门安全的编程语言，但这种安全并不是没有bug，而是我们保障内存安全的的基础上同时提供高性能而且采用一直前进的编程语言范式。</p></blockquote><p>或许，内存安全相对于安全是一个更好的名词，有些开发者可能更偏向于得到一个 optional 的返回值，而不是在数组越界访问的问题里纠结，每个人都同意直接让程序crash会好过让程序携带着非法的数据继续运行下去，而这种情况还可能会被栈溢出的攻击所利用。</p><p>第二种权衡（直接 crash 而不是允许越界访问）的决定看起来显而易见，但是有些语言不会做这种保证，在 C 中，访问越界的数组将会导致未知的行为（具体取决于使用的编译器对这种行为的实现），在 Swift 中开发者会快速的意识到自己犯了类似数组越界的错误，Swift团队觉得这是一个合适的 crash 时机，所以并不会返回一个 optional 甚至是返回一段未知的数据。</p><p>使用这里”安全”的定义也明确了”不安全”的 API 的定义，因为它们直接访问内存进行编程，程序员们自己必须十分小心保证自己不会访问到无效的内存，这点尤为困难，即使专家在这种情景也会犯错，如果对这个主题感兴趣去查阅 <a href="https://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html" target="_blank" rel="noopener">Matt Gallagher的博客</a>中以安全的方式桥接 C 到 Swift 的相关讨论。</p><p>Swift 的团队对于安全的定义可能与你预想的并不完全一致，但是它们的种种策略确实可以避免大多数的程序员去考虑各种常见的 bug，将“安全”的定义细化为“内存安全”可以让我更好的理解 Swift 团队对于安全的定义。</p><blockquote><p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg">http://swift.gg</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作者：Soroush Khanlou，&lt;a href=&quot;http://khanlou.com/2017/04/safety-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;，原文日期：2017-04-05&lt;br&gt;译者：&lt;a href=&quot;undefined&quot;&gt;Doye&lt;/a&gt;；校对：&lt;a href=&quot;http://chengway.in/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;walkingway&lt;/a&gt;；定稿：&lt;a href=&quot;https://github.com/chenmingbiao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMB&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--此处开始正文--&gt;
&lt;p&gt;Swift 是一门注重安全性的语言，如&lt;a href=&quot;https://Swift.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift官网&lt;/a&gt;的&lt;a href=&quot;https://Swift.org/about/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于页面&lt;/a&gt;中所言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swift 是一门通用编程语言，采用现代化的方法来保证安全性与性能，套用软件设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="khanlou.com" scheme="https://swift.gg/categories/khanlou-com/"/>
    
    
      <category term="Swift 进阶" scheme="https://swift.gg/tags/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
